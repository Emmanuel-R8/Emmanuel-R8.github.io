<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neural Network | Back2Numbers</title>
    <link>/category/neural-network/</link>
      <atom:link href="/category/neural-network/index.xml" rel="self" type="application/rss+xml" />
    <description>Neural Network</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Emmanuel Rialland 2021</copyright><lastBuildDate>Sat, 07 Mar 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Neural Network</title>
      <link>/category/neural-network/</link>
    </image>
    
    <item>
      <title>RNN Compressive Memory Part 1: A high level introduction.</title>
      <link>/post/2020/03/07/rnn-compressive-memory-part-1/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/post/2020/03/07/rnn-compressive-memory-part-1/</guid>
      <description>
&lt;script src=&#34;../../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#recurrent-neural-networks-rnn&#34;&gt;Recurrent Neural Networks (&lt;em&gt;RNN&lt;/em&gt;)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#from-simple-rnns-to-lstms&#34;&gt;From simple RNNs to LSTMs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#longshort-term-memory-rnns&#34;&gt;Long/Short Term Memory RNNs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#attention&#34;&gt;Attention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#beyond-lstm-transformers&#34;&gt;Beyond LSTM: Transformers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#transformer-xl&#34;&gt;Transformer-XL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compressive-transformers&#34;&gt;Compressive Transformers&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compression-scheme&#34;&gt;Compression scheme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compression-training&#34;&gt;Compression training&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#summary&#34;&gt;Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;This is the first post of series dedicated to Compressive Memory of Recurrent Neural Networks. This is inspired by a recent DeepMind paper published in November 2019 on &lt;a href=&#34;https://arxiv.org/abs/1911.05507&#34;&gt;Arxiv&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Currently, the ambition of the series is to follow this plan:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Part 1 (here): A high level introduction to Compressive Memory mechanics starting from basic RNNS;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;../rnn-compressive-memory-part-1/index.html&#34;&gt;Part 2&lt;/a&gt;: a detailed explanation of the TransformerXL;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 3: an implementation using PyTorch (soon);&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 4: finally, its application to time series (soon).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most likely, this will be fine-tuned over time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Big thanks to &lt;a href=&#34;https://gmarti.gitlab.io/&#34;&gt;Gautier Marti&lt;/a&gt; and &lt;a href=&#34;http://zoonek.free.fr/blosxom/&#34;&gt;Vincent Zoonekynd&lt;/a&gt; for their suggestions and proof-reading!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Additional diagrams (14 March 2020)&lt;/p&gt;
&lt;div id=&#34;recurrent-neural-networks-rnn&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Recurrent Neural Networks (&lt;em&gt;RNN&lt;/em&gt;)&lt;/h2&gt;
&lt;div id=&#34;from-simple-rnns-to-lstms&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;From simple RNNs to LSTMs&lt;/h3&gt;
&lt;p&gt;Traditional neural networks were developed to train/run on information provided in a single step in a consistent format (e.g. images with identical resolution). Conceptually, a neural network could similarly be taught on sequential information (e.g. a video as a series of images) looking at it as a single sample, but that would require (1) being trained on the full sequence (e.g. an entire video), (2) being able to cope with information of variable length (i.e. short vs. long video). (1) is computationally intractable, and (2) means that units analysing later parts of the video would not be receiving as much training as earlier units when ideally they should be all share the same amount of training .&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;assets/Recurrent_neural_network_unfold.svg&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;strong&gt;Basic RNN&lt;/strong&gt; (source: &lt;em&gt;Wikipedia&lt;/em&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The original RNN address those issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sequences are chopped in small consistent sub-sequences (say, a &lt;em&gt;segment&lt;/em&gt; of 10 images, or a group of 20 words).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An RNN layer is a group of blocks (or &lt;em&gt;cells&lt;/em&gt;), each receiving a single element of the segment as input. Note that here &lt;em&gt;layer&lt;/em&gt; does not have the traditional meaning of a layer of neural units fully connected to a previous layer of units. It is a layer of RNN cells. Within each cell, quite a few things happen, including using layers of neural units. From here on, a &lt;em&gt;layer&lt;/em&gt; will refer to an &lt;em&gt;RNN layer&lt;/em&gt; and not a layer of neural units..&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Within a layer, cells are identical: they have the same parameters.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Although each element of a sequence might be of interest on its own, it only becomes really meaningful in the context of the other elements. Each cell contains a state vector (called &lt;em&gt;hidden state&lt;/em&gt;). Each cell is trained using an individual element from a segment and the hidden state from the preceding cell. Training the network means training the creation of those states. Passing of the hidden state transfers some context or memory from prior elements of the segment. The cells receiving a segment form a single layer. Each cell would typically (but not necessarily) also include an additional sub-cell to create an output as a function of the hidden step. In that case, the output of a layer can then be used as input of new RNN layer.&lt;/p&gt;
&lt;p&gt;A layer is trained passing hidden states from prior cells to later cells. The hidden state from prior elements is used to contextualise a current element. To use context from later elements (e.g. in English, a noun giving context to a preceding adjective), a separate layer is trained where context instead passes from later to prior elements. Those forward and backward layers jointly create a &lt;em&gt;bidirectional RNN&lt;/em&gt; .&lt;/p&gt;
&lt;p&gt;Historically, RNNs applied to NLP deal with elements which are either one-hot encoded (either letters, or, more efficient, tokens), or word embeddings often normalised as unit vectors (for example see &lt;a href=&#34;https://nlp.stanford.edu/projects/glove/&#34;&gt;Word2Vec&lt;/a&gt; and &lt;a href=&#34;https://nlp.stanford.edu/projects/glove/&#34;&gt;GloVe&lt;/a&gt;). RNN cells therefore deal with values between 0 and 1. Typically, non-linearity is brought by &lt;span class=&#34;math inline&#34;&gt;\(tanh\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(sigmoid\)&lt;/span&gt; activations which guarantee unit values within that range. Those activation functions quickly have very flat gradients. Segments often have 10s or 100s of elements. Because of vanishing gradients, a hidden state receives little information from distant cells (training gradients are hardly influenced by gradients of distant cells).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;longshort-term-memory-rnns&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Long/Short Term Memory RNNs&lt;/h3&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;assets/Long_Short-Term_Memory.svg&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;strong&gt;Basic LSTM RNN&lt;/strong&gt; (source: &lt;em&gt;Wikipedia&lt;/em&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Long/Short Term Memory RNNs (&lt;em&gt;LSTM&lt;/em&gt;) address this by passing two states:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a hidden state &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; as described above trained with non-linearity: this is the &lt;em&gt;short-term memory&lt;/em&gt;; and,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;another hidden state &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; (called &lt;em&gt;context&lt;/em&gt;) weighting previous contexts with a simple exponential moving average (in &lt;em&gt;Gated Recurrent Units&lt;/em&gt;) or a slightly more complicated version thereof in the original LSTM model structure. Determining the optimal exponential decay is part of the training process. This minimally processed state is the &lt;em&gt;long-term memory&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LTSM can also be made bidirectional.&lt;/p&gt;
&lt;p&gt;Without going into further details, note that each &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\tanh\)&lt;/span&gt; orange block represents matrix of parameters to be learned.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;attention&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Attention&lt;/h3&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;assets/Attention_RNN.svg&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;strong&gt;Attention RNN&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RNN were further extended with an &lt;em&gt;attention mechanism&lt;/em&gt;. Blog posts on attention by &lt;a href=&#34;https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/&#34;&gt;Jay Alammar&lt;/a&gt; and &lt;a href=&#34;https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html&#34;&gt;Lilian Weng&lt;/a&gt; are good introductions.&lt;/p&gt;
&lt;p&gt;A multi-layer RNN takes the output a layer and uses it as input for the next. With the attention mechanism, the outputs go through an attention unit.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;beyond-lstm-transformers&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Beyond LSTM: Transformers&lt;/h3&gt;
&lt;p&gt;RNNs were then simplified (insert large air quotes) with &lt;em&gt;Transformers&lt;/em&gt; (using what is called &lt;em&gt;self-attention&lt;/em&gt;) that significantly reduce the number of model parameters and can be efficiently parallelised with minimum model performance impact. For an extremely clear introduction to those significant improvements, you cannot do better than reading , and by &lt;a href=&#34;http://www.peterbloem.nl/blog/transformers&#34;&gt;Peter Bloem&lt;/a&gt; on transformers. The following assumes that you are broadly familiar with those ideas.&lt;/p&gt;
&lt;p&gt;The basic transformer structure uses self-attention where, for a given element (the &lt;em&gt;query&lt;/em&gt;), the transformer looks at the other elements of the segment (the &lt;em&gt;keys&lt;/em&gt;) to determine how much ‘attention’ other elements of the segment influence the role of the query in changing the hidden state.&lt;/p&gt;
&lt;p&gt;Broadly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The query is projected in some linear space (a matrix &lt;span class=&#34;math inline&#34;&gt;\(W_q\)&lt;/span&gt;). That’s basically an embedding which is part of the model training.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All the other elements, the keys, are projected in another linear space (a matrix &lt;span class=&#34;math inline&#34;&gt;\(W_k\)&lt;/span&gt;); another embedding which is part of the model training.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The similarity (perharps &lt;em&gt;affinity&lt;/em&gt; would be a better word) between the projected query and each projected key is calculated with a dot product / cosine distance. This is exactly the approach of basic recommender systems with the difference that the recommendation is between sets of completely different nature (for example affinity between users and movies). Note that although query and keys are elements of identical type, they are embedded into different spaces with different projections matrices.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We now have a vector of the same size as the segment length (one cosine distance per input element). It goes through another layer (a matrix &lt;span class=&#34;math inline&#34;&gt;\(W_v\)&lt;/span&gt;) to give a &lt;em&gt;value&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The triplet of &lt;span class=&#34;math inline&#34;&gt;\(\left( W_q, W_k, W_v \right)\)&lt;/span&gt; is called an &lt;em&gt;attention head&lt;/em&gt;. Actual models would include multiple heads (of the order of 10), and the output of a transformer layer could then feed into a new transformer layer.&lt;/p&gt;
&lt;p&gt;This model is great until you notice that the dot product / cosine similarity is commutative and does not reflect whether a key element is located before or after the query element: order is fundamental to sequential information (“quick fly” vs. “fly quick”). To address this, the input elements are always enriched with a positional embedding: the input elements are concatenated with positional information showing where they stand within a segment.&lt;/p&gt;
&lt;p&gt;Note that a transformer layer is trained on a segment using only the information from that segment. This is fine to train on sentences, but it cannot really account for more distant relationships between words within a lengthy paragraph, let alone a full text.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;transformer-xl&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Transformer-XL&lt;/h3&gt;
&lt;p&gt;Transformers have been further improved with &lt;a href=&#34;https://ai.googleblog.com/2019/01/transformer-xl-unleashing-potential-of.html&#34;&gt;Tranformer-XL&lt;/a&gt; (XL = extra long) which are trained using hidden states from previous segments, therefore using information from several segments, to improve a model’s memory span.&lt;/p&gt;
&lt;p&gt;Conceptually, this is an obvious extension of the basic transformer to increase its memory span. But there is a fundamental problem. Going back to the basic transformer, each element includes its absolute position within the segment. The position of the first word of the segment is 1, that of the last one is, say, 250 . Such a scheme breaks down as soon as the state of the previous segment is taken into account. Word 1 of the current segment obviously comes before word 250, but has to come after word 250 of the previous segment. The absolute position encoding does not reflect the relative position of elements located in different segments.&lt;/p&gt;
&lt;p&gt;The key contribution of the Transformer-XL is to develop a relative positional encoding that allows hidden state information to cross segment boundaries. In their implementation, the authors evaluate that the attention length, being basically how many hidden states are used, is 450% longer that the basic transformer. That’s going from sentence length to full paragraph, but still far from a complete book.&lt;/p&gt;
&lt;p&gt;A side, but impressive, benefit is that the evaluation speed of the model, or it use once trained, is significantly increased thanks to the relative addressing (the paper states up to a 1,800-fold increase depending on the attention length).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;compressive-transformers&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Compressive Transformers&lt;/h2&gt;
&lt;p&gt;Full text understanding cannot be achieved by simply lengthening segment sizes from 100s to the &lt;a href=&#34;https://blog.reedsy.com/how-many-words-in-a-novel/&#34;&gt;word count&lt;/a&gt; of a typical novel (about 100,000). When training a model routinely takes 10s of hours on GPU clusters, an increase by 3 orders of magnitude is not realistic.&lt;/p&gt;
&lt;p&gt;In a recent &lt;a href=&#34;https://arxiv.org/abs/1911.05507&#34;&gt;paper&lt;/a&gt;, DeepMind proposes a new RNN model called &lt;em&gt;Compressive Transformers&lt;/em&gt;.&lt;/p&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Transformer-XL uses the hidden state of a prior segment (&lt;span class=&#34;math inline&#34;&gt;\(h_{T-1}\)&lt;/span&gt;) to improve the training of the current segment (&lt;span class=&#34;math inline&#34;&gt;\(h_{T}\)&lt;/span&gt;). When moving to the next segment, training (&lt;span class=&#34;math inline&#34;&gt;\(h_{T+1}\)&lt;/span&gt;) now only uses &lt;span class=&#34;math inline&#34;&gt;\(h_{T}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(h_{T-1}\)&lt;/span&gt; is discarded. To increase the memory span, one could train using more past segments at the expense of increase in memory usage and computation time (quadratic). The actual Transformer-XL uses the hidden states of several previous segments, but the discarding mechanism will remain.&lt;/p&gt;
&lt;p&gt;The key contribution of the Compressive Transformers is the ability to retain salient information from those otherwise discarded past states. Instead of being discarded, they are stored in compressed form.&lt;/p&gt;
&lt;p&gt;Each Transformer-XL layer is now trained with prior hidden states (&lt;em&gt;primary memory&lt;/em&gt;) and the &lt;em&gt;compressed memory&lt;/em&gt; of older hidden states.&lt;/p&gt;
&lt;p&gt;As an aside, although not explicitly mentioned, we should note that the ‘-XL’ aspect of the Transformer-XL and the memory compression mechanics are conceptually independent from the actual types of RNN cell. Simple RNNs, GRUs or LSTMs could be trained using the hidden states of past segments (not dissimilar to state/context peeking into past cells in certain RNN variants). But the performance benefit of Transformer-XL is such that the paper only focuses on transformer-XL.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;compression-scheme&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Compression scheme&lt;/h3&gt;
&lt;p&gt;As compared to Transformer-XL, the key difference is the compression scheme. The rest of the model seems identical.&lt;/p&gt;
&lt;div id=&#34;size-parameters&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Size parameters&lt;/h4&gt;
&lt;p&gt;The size of the model is described with a few size parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt;: size of a segment = the number of cells in a layer.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n_m\)&lt;/span&gt;: number of hidden states in the primary uncompressed memory (like the Transformer-XL). &lt;span class=&#34;math inline&#34;&gt;\(n_m\)&lt;/span&gt; is a multiple of &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt;. The primary memory is a FIFO buffer: the first (oldest) memories will be the first to be later compressed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n_{cm}\)&lt;/span&gt;: number of compressed hidden states in the compressed memory. States in the compressed memory will compress an old segment of size &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt; dropping out of the primary memory. &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; is an information compression ratio from &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt; primary memory entries into compressed memory entries. There can be two ways of applying this compression ratio, which both reduce the number of hidden states by the same ratio:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; uncompressed layers could create a single compressed hidden state of identical size. This merges the information of a group of elements (e.g. &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; words) into a single hidden state. In this case, &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt; is proportional to &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(n_{cm}\)&lt;/span&gt; is proportional to &lt;span class=&#34;math inline&#34;&gt;\(n_s / c\)&lt;/span&gt;. The authors do not use this approach. It would enforce a sub-segmentation of an uncompressed segment at arbitrary intervals (why group 3 words instead of 5 or 7…)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instead, the authors use dimension reduction: a single uncompressed hidden state is compressed into a new hidden state with &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; times fewer hidden states. If the size of the hidden state of a Transformer-XL cell is &lt;span class=&#34;math inline&#34;&gt;\(n_h\)&lt;/span&gt;, hidden states in the primary memory will have the same size, and the compressed memory hidden states will have a size of &lt;span class=&#34;math inline&#34;&gt;\(n_h / c\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By way of example, a segment could have 100 cells (&lt;span class=&#34;math inline&#34;&gt;\(n_s = 100\)&lt;/span&gt;). This segment could be trained with the hidden states of the past 3 segments’ training (&lt;span class=&#34;math inline&#34;&gt;\(n_m = 3 * n_s = 300\)&lt;/span&gt;). When training the next segment, an old segment of size 100 becomes available for compression which will create 100 new hidden states.&lt;/p&gt;
&lt;p&gt;This example is for a single layer. The same scheme would be replicated for each layer of the model&lt;/p&gt;
&lt;p&gt;Note that the paper only contemplates a single set of compressed memories. There could also be multiple generations of compressed memories, primary memory compresses in generation 1, then compressing into generation 2…&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;compression-functions&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Compression functions&lt;/h4&gt;
&lt;p&gt;A compressed hidden state is created from &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; primary memory hidden states. When training on texts with word embeddings,the authors used a value of &lt;span class=&#34;math inline&#34;&gt;\(c=3\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(c=4\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Several compression schemes are explored in the paper:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;max or mean pooling with a stride of &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;. This is typical of image convolution networks - no explanation required.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1-dimensional convolution with a stride of &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;. This is also typical of image convolution network apart from being one-dimensional. This requires parameter training.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/1511.07122.pdf&#34;&gt;dilated convolution&lt;/a&gt;. In practice image convolutions have shown to be inadequate for sequential information where dependencies can be at both short and long ranges: working at different scales makes sense. Dilated convolutions use convolution filters that are contracted and dilated versions of a template to be trained.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a &lt;em&gt;most-used&lt;/em&gt; mechanism that identifies and retains part of the hidden states according to their importance in the cells training gauged by the attention they received.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;compression-training&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Compression training&lt;/h3&gt;
&lt;p&gt;Training the compression parameters is done separately from the optimisation of the Transformer-XL cells.&lt;/p&gt;
&lt;p&gt;The purpose of the compressed memory is to provide a compressed and lossy representation of the primary memory (hidden states) or the attention heads parameters: the quality of the compression mechanics is assessed by how well the original information can be re-generated from it. In essence, the compressed hidden states are a compressed representations to a learned representation vector in an auto-encoder. This is the training mechanics used by the authors.&lt;/p&gt;
&lt;p&gt;As in an auto-encoder, the representation is learned by comparing the original information to its reconstruction. This training is kept completely independent from the training of the transformers: the auto-encoding loss and gradients do not impact the attention heads’ parameters.&lt;/p&gt;
&lt;p&gt;Conversely, the loss and gradients of the attention heads’ training do not flow into the training of the compression scheme.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;summary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This was a high level introduction of RNNs all the way up to Compressive Memory mechanics. Next, the algorithm’s nitty-gritty.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Neural Network - Incremental Growth</title>
      <link>/post/2019/10/23/neural-network-incremental-growth/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/post/2019/10/23/neural-network-incremental-growth/</guid>
      <description>
&lt;script src=&#34;../../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#draft-1&#34;&gt;&lt;strong&gt;&lt;em&gt;DRAFT 1&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#background&#34;&gt;Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#singular-matrix-decomposition&#34;&gt;Singular matrix decomposition&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#where-next&#34;&gt;Where next?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#back-to-svd&#34;&gt;Back to SVD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#regularisation&#34;&gt;Regularisation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#vector-coordinates&#34;&gt;Vector coordinates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eigenvalues&#34;&gt;Eigenvalues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#threshold&#34;&gt;Threshold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#by-2-decision-matrix&#34;&gt;2-by-2 decision matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#todo-other-principal-components-methods&#34;&gt;[TODO] Other Principal Components methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#limitations-and-further-questions&#34;&gt;Limitations and further questions&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#further-questions&#34;&gt;Further questions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#litterature&#34;&gt;Litterature&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;div id=&#34;draft-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;strong&gt;&lt;em&gt;DRAFT 1&lt;/em&gt;&lt;/strong&gt;&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;We all have laptops. But le’ts face it, even in times of 32GB of RAM and NVMe2 drives, forget about running any interesting TensorFlow model. You need to get an external GPU, build your own rig, or very quickly pay a small fortune for cloud instances.&lt;/p&gt;
&lt;p&gt;Back in 1993, I read a paper about growing neural networks neuron-by-neuron. I have no other precise recollection about this paper apart from the models considered being of the order of 10s of neurons and the weight optimisation being made on a global basis, i.e. not layer-by-layer like backpropagation. Nowadays, it is still too often the case that finding a network structure that solves a particular problem is a random walk: how many layers, with how many neurons, with which activation functions? Regularisation methods? Drop-out rate? Training batch size? The list goes on.&lt;/p&gt;
&lt;p&gt;This got me thinking about how a training heuristic could incrementally modify a network structure given a particular training set and, apart maybe from a few hyperparameters, do that with no external intervention. At regular training intervals, a layer&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; will be modified depending on what it &lt;em&gt;seems&lt;/em&gt; able or not to achieve. As we will see, we will use unsupervised learning methods to do this: a layer modification will be independent of the actual learning problem and automatic.&lt;/p&gt;
&lt;p&gt;Many others have looked into that. But what I found regarding self-organising networks is pre-2000, and nothing in the context of deep learning. So it seems that the topic has gone out of fashion because of the current amounts of computing power, or has been set aside for reasons unknown. (See references at the end). In any event, it is interesting enough a question to research it.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;background&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Background&lt;/h1&gt;
&lt;p&gt;Let us look at a simple 1-D layer and decompose what it exactly does. Basically a layer does:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\text{ouput} = f(M \times \text{input})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If the input &lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; has size &lt;span class=&#34;math inline&#34;&gt;\(n_I\)&lt;/span&gt;, the output &lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt; has size &lt;span class=&#34;math inline&#34;&gt;\(n_I\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; being the activation function, we have (where &lt;span class=&#34;math inline&#34;&gt;\(\odot\)&lt;/span&gt; represents the matrix element-wise application of a function):&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
O = f \odot (M \times I)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Then, looking at &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;, what does it really do? At one extreme, if &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; was the identity matrix, it would essentially be useless (bar the activation function&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;). This would be a layer candidate for deletion. The question is then:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Looking at the matrix representing a layer, can we identify which parts are (1) useless, (2) useful and complex enough, or (3) useful but too simplistic?&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here, &lt;em&gt;complex enough&lt;/em&gt; or &lt;em&gt;simplistic&lt;/em&gt; is basically a synonym of “&lt;em&gt;one layer is enough&lt;/em&gt;”, or “&lt;em&gt;more layers are necessary&lt;/em&gt;”.&lt;/p&gt;
&lt;p&gt;The idea to look for important/complex information which where the network needs to grow more complex; and identify trivial information which can be discarded, or can be viewed as minor adjustments to improve error rates (basically overfitting…)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Caveat&lt;/em&gt;: Note that we ignore the activation function. They are key to introduce non-linearity. Without it, a network is only a linear function, i.e. no interest. They have a clear impact on the performance of a network.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;singular-matrix-decomposition&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Singular matrix decomposition&lt;/h1&gt;
&lt;p&gt;There exists many ways to decompose a matrix. Singular matrix decomposition (&lt;em&gt;SVD&lt;/em&gt;) &lt;span class=&#34;math inline&#34;&gt;\(M = O \Sigma I^\intercal\)&lt;/span&gt; is an easy and efficient way to interpret what a given matrix does. SVD builds on the eigenvectors (expressed in an orthonormal basis), and eigenvalues. (Note that &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; is real-valued, so we use the transpose notation &lt;span class=&#34;math inline&#34;&gt;\(M^\intercal\)&lt;/span&gt; instead of the conjugate transpose &lt;span class=&#34;math inline&#34;&gt;\(M^*\)&lt;/span&gt;.)&lt;/p&gt;
&lt;p&gt;In a statistical world, SVD (with eigenvalues ordered by decreasing value) is how to do principal component analysis(&lt;em&gt;PCA&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;In a geometrical context, SVD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;takes a vector (expressed in the orthonormal basis);&lt;/li&gt;
&lt;li&gt;re-expresses onto a new basis made of the eigenvectors (that would only exceptionally be orthonormal);&lt;/li&gt;
&lt;li&gt;dilates/compresses those components by the relevant eigenvalues;&lt;/li&gt;
&lt;li&gt;and returns this resulting vector expressed back onto the orthonormal basis.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As presented here, this explanation requires a bit more intellectual gymnastic when the matrix is not square (i.e. when the input and output layers have different dimensions), but the principle remains identical.&lt;/p&gt;
&lt;div id=&#34;where-next&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Where next?&lt;/h3&gt;
&lt;p&gt;Taking the statistical and geometrical points of view together, the layer (matrix &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;) shuffles the input vector in its original space space where some specific directions are more important than others. Those directions are linear combinations of the input neurons, each combinations is along the eigenvectors. Those combinations are given more or less importance as expressed by the eigenvalues. (Note that the squares of the eigenvalues expressed how much information each combination brings to the table.)&lt;/p&gt;
&lt;p&gt;Intuitively, the simplest and most useless &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; would be the identity matrix (the input units are repeated), or zero matrix (the input units are dropped because useless). Let us repeat the caveat that the activation function is ignored.&lt;/p&gt;
&lt;p&gt;If compared to the identity matrix, the SVD shows that &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; includes (at least) two types of important information identified:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What are interesting combinations of the input units? This is expressed by how much the input vector is rotated in space.&lt;/li&gt;
&lt;li&gt;Independently from whether a combination is complicated or not (i.e. multiple units, or unit passthrough), how an input is amplified (as expressed by the eigenvalues).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The idea is then produce a 2x2 decision matrix with high/low rotation mess and high/low eigenvalues.&lt;/p&gt;
&lt;p&gt;A picture is gives the intuition of what we are after:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;assets/Network-Incremental-Growth-Matrix-Split.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Transformation of the Layer Matrix&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Looking from top to bottom at what the “after” matrices would be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Part of the original layer, immediately followed by a new one (we will see below what that would look like). The intuition is that this layer is really messing things up down the line, or seems very sensitive.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part of the original layer where the number of units would be increased (here doubled as an example).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part of the original layer kept &lt;em&gt;functionally&lt;/em&gt; essentially as is.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Delete the rest which is either not sensitive to input or outputs nothings. This would be within a certain precision. That is basically a form of regularisation preventing the overall model to be too sensitive. I am aware that there are other types of regularisations, but that will go in the limitations category.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The next layer would take as input all the transformed outputs.&lt;/p&gt;
&lt;p&gt;In practice, the picture presents the matrices separated. This is for ease of understanding. In reality the same effect would be achieved if the three dark blue sub-layers are merged in a single layer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;back-to-svd&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Back to SVD&lt;/h1&gt;
&lt;p&gt;Let us assume that there are &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; input units and &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; output units. &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; then is of dimensions &lt;span class=&#34;math inline&#34;&gt;\(m \times n\)&lt;/span&gt;. The matrices of the SVD have dimensions:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{matrix}
M          &amp;amp; = &amp;amp; O          &amp;amp; \Sigma     &amp;amp; I^\intercal \\
m \times n &amp;amp;   &amp;amp; m \times m &amp;amp; m \times n &amp;amp; n \times n \\
\end{matrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that instead of using &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt; to name the sub-matrices of the SVD, we use &lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt; to represent &lt;em&gt;input&lt;/em&gt; and &lt;em&gt;output&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt; can be written as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
I =
\begin{pmatrix} |   &amp;amp;        &amp;amp; |    \\ i_1 &amp;amp; \cdots &amp;amp; i_m  \\ |   &amp;amp;        &amp;amp; |    \\ \end{pmatrix}
\qquad \text{and} \qquad
O =
\begin{pmatrix} |   &amp;amp;       &amp;amp; | \\ o_1 &amp;amp; \cdots &amp;amp; o_n \\ |   &amp;amp;       &amp;amp; | \\ \end{pmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Then:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
M &amp;amp; = O \Sigma I^\intercal \\
  &amp;amp; =      \begin{pmatrix}    |  &amp;amp;       &amp;amp;   |    \\
                             o_1 &amp;amp; \dots &amp;amp;  o_m   \\
                              |  &amp;amp;       &amp;amp;   |    \\ \end{pmatrix}                                                    \times \\
  &amp;amp; \times \begin{pmatrix} \sigma_1 \\ &amp;amp; \sigma_2 \\ &amp;amp;&amp;amp; \ddots \\ &amp;amp;&amp;amp;&amp;amp; \sigma_r \\ &amp;amp;&amp;amp;&amp;amp;&amp;amp; 0 \\ &amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp; \ddots \\ &amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp; 0 \\ \end{pmatrix} \times \\
  &amp;amp; \times \begin{pmatrix}    -  &amp;amp;  i_1   &amp;amp; -     \\
                                 &amp;amp; \vdots &amp;amp;       \\
                              -  &amp;amp;  i_n   &amp;amp; -     \\ \end{pmatrix}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt; has &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; non-zero eigenvalues.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;regularisation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Regularisation&lt;/h1&gt;
&lt;p&gt;At this stage, we can regularise all components.&lt;/p&gt;
&lt;div id=&#34;vector-coordinates&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Vector coordinates&lt;/h2&gt;
&lt;p&gt;For each vector &lt;span class=&#34;math inline&#34;&gt;\(i_k\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(o_k\)&lt;/span&gt;, we could zero its coordinates when below a certain threshold (in absolute value). All the coordinates will &lt;span class=&#34;math inline&#34;&gt;\(-\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; since each vector has norm 1 (&lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt; are orthonormal), therefore all of them will be regularised in similar ways.&lt;/p&gt;
&lt;p&gt;After regularisation, the matrices will not be orthonormal anymore. They can easily be made normal by scaling up by &lt;span class=&#34;math inline&#34;&gt;\(\frac{1}{\sum_{k}i_k^2}\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(\frac{1}{\sum_{k}o_k^2}\)&lt;/span&gt;. There is no generic way to revert to an orthogonal basis and keep the zeros.&lt;/p&gt;
&lt;p&gt;We need a way to measure the &lt;code&gt;rotation messiness&lt;/code&gt; of each vector. As a shortcut, we can use the proportion of non-zero vector coordinates (after &lt;em&gt;de minimis&lt;/em&gt; regularisation).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;eigenvalues&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Eigenvalues&lt;/h2&gt;
&lt;p&gt;The same can be done for the &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;s. As an avenue of experimentation, those values can not only be zero-ed in places, but also rescale the large values in some non-linear way (e.g. logarithmic or square root rescaling).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;threshold&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Threshold&lt;/h2&gt;
&lt;p&gt;Where to set the threshold is to be experimented with. Mean? Median since more robust? Some quartile?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;by-2-decision-matrix&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2-by-2 decision matrix&lt;/h2&gt;
&lt;p&gt;Based on those regularisation, we would propose the following:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{matrix}
                    &amp;amp; \text{low rotation messiness} &amp;amp; \text{high rotation messiness} \\
\text{high } \sigma &amp;amp; \text{Double height}          &amp;amp; \text{Double depth}            \\
\text{low } \sigma  &amp;amp; \text{Delete}                 &amp;amp; \text{Keep identical}          \\
\end{matrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;todo-other-principal-components-methods&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;[TODO] Other Principal Components methods&lt;/h1&gt;
&lt;p&gt;SVD is PCA. Projects information on hyperplanes.&lt;/p&gt;
&lt;p&gt;Reflect on non-linear versions: Principal Curves, Kernel Principal Components, Sparse Principal Components, Independent Component Analysis. (_Elements of Statistical Learning s. 14.5 seq.).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;limitations-and-further-questions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Limitations and further questions&lt;/h1&gt;
&lt;div id=&#34;limitations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Limitations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Only 1-D layers. Higher-order SVD is in principle feasible for higher order tensors. Other methods?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We delete the eigenvectors associated to low eigenvalues and limited rotations. There are other forms of regularisations, e.g. random weight cancelling that would not care about anything eigen-.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;What is the real impact of ignoring the activation function? PCA requires centered values. Geometrically, uncentered values would mean more limited rotations since samples would be in quadrant far from 0.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;further-questions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Further questions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The final structure is a direct product of the training set. What if the training is done differently (batches sized or ordered differently)?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;What about training many variants with different subsets of the training set and using ensemble methods?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The eigenvalues could be modified when creating the new layers. By decreasing the highest eigevalues (in absolute value), we effectively regularise the layers outputs. This decrease could bring additional non-linearity if the compression ratio depends on the eigengevalue (e.g. replacing it by it square root). And this non-linearty would not bring additional complexity to the back-propagation algorithm, or auto-differentiated functions: it only modifies the final values if the new matrices.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;litterature&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Litterature&lt;/h1&gt;
&lt;p&gt;Here are a few summary litterature references related to the topic.&lt;/p&gt;
&lt;div id=&#34;the-elements-of-statistical-learning&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;The Elements of Statistical Learning&lt;/h4&gt;
&lt;p&gt;The ESL top of p 409 proposes PCA to interpret layers, i.e. to improve the interpretability of the decisions made by a network.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;neural-network-implementations-for-pca-and-its-extensions&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Neural Network Implementations for PCA and Its Extensions&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://downloads.hindawi.com/archive/2012/847305.pdf&#34; class=&#34;uri&#34;&gt;http://downloads.hindawi.com/archive/2012/847305.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Uses neural networks as a substitute for PCA.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;an-incremental-neural-network-construction-algorithm-for-training-multilayer-perceptrons&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;An Incremental Neural Network Construction Algorithm for Training Multilayer Perceptrons&lt;/h4&gt;
&lt;p&gt;Aran, Oya, and Ethem Alpaydin. “An incremental neural network construction algorithm for training multilayer perceptrons.” Artificial Neural Networks and Neural Information Processing. Istanbul, Turkey: ICANN/ICONIP (2003).&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cmpe.boun.edu.tr/~ethem/files/papers/aran03incremental.pdf&#34; class=&#34;uri&#34;&gt;https://www.cmpe.boun.edu.tr/~ethem/files/papers/aran03incremental.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;kohonen-maps&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Kohonen Maps&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Self-organizing_map&#34; class=&#34;uri&#34;&gt;https://en.wikipedia.org/wiki/Self-organizing_map&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;self-organising-network&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Self-Organising Network&lt;/h4&gt;
&lt;div id=&#34;a-self-organising-network-that-grows-when-required-2002&#34; class=&#34;section level5&#34;&gt;
&lt;h5&gt;A Self-Organising Network That Grows When Required (2002)&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8763&#34; class=&#34;uri&#34;&gt;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8763&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-cascade-correlation-learning-architecture&#34; class=&#34;section level5&#34;&gt;
&lt;h5&gt;The Cascade-Correlation Learning Architecture&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.125.6421&#34; class=&#34;uri&#34;&gt;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.125.6421&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Growth with quick freeze as a way to avoid the expense of back-propagation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;soinnself-organizing-incremental-neural-network&#34; class=&#34;section level5&#34;&gt;
&lt;h5&gt;SOINN：Self-Organizing Incremental Neural Network&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;http://www.haselab.info/soinn-e.html&#34; class=&#34;uri&#34;&gt;http://www.haselab.info/soinn-e.html&lt;/a&gt;
&lt;a href=&#34;https://cs.nju.edu.cn/rinc/SOINN/Tutorial.pdf&#34; class=&#34;uri&#34;&gt;https://cs.nju.edu.cn/rinc/SOINN/Tutorial.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Seems focused on neuron by neuron evolution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;We will only consider modifying the network layer by layer, not neuron by neuron.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;This could actually be a big limitation of this discussion. In reality, even an identity matrix yields changes by piping the inputs through a new round of non-linearity, which is not necessarily identical to the preceding layer&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
