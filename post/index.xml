<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Back2Numbers</title>
    <link>/post.html</link>
      <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Emmanuel Rialland 2020</copyright><lastBuildDate>Thu, 31 Dec 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Posts</title>
      <link>/post.html</link>
    </image>
    
    <item>
      <title>RNN Compressive Memory Part 3: The Compression algorithm</title>
      <link>/2020/12/31/rnn-compressive-memory-part-3-the-compression-algorithm.html</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/2020/12/31/rnn-compressive-memory-part-3-the-compression-algorithm.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#the-transformerxl&#34;&gt;The TransformerXL&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#background&#34;&gt;Background&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compressive-memory&#34;&gt;Compressive Memory&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#background-1&#34;&gt;Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#model-overall-structure&#34;&gt;Model overall structure&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#memory-compression&#34;&gt;Memory compression&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#compression-function&#34;&gt;Compression function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#loss-function&#34;&gt;Loss function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#model-timing&#34;&gt;Model timing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#attention-reconstruction-loss&#34;&gt;Attention-Reconstruction Loss&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notation-summary&#34;&gt;Notation summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;This is part 3 of a discussion of the DeepMind paper about &lt;a href=&#34;https://arxiv.org/abs/1911.05507&#34;&gt;Compressive Transformers for Long-Range Sequence Modelling&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;../07/rnn-compressive-memory-part-1.html&#34;&gt;Part 1&lt;/a&gt;: A high level introduction to Compressive Memory mechanics starting from basic RNNS;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 2 (here): a detailed explanation of the TransformerXL;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 3: an implementation using PyTorch;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 4: finally, its application to time series.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post describes the building blocks up to what makes a &lt;a href=&#34;https://arxiv.org/abs/1901.02860&#34;&gt;TransformerXL&lt;/a&gt; model as presented in June 2019. The compression mechanics are an add-on to the TransformerXL which therefore need to be detailed. Along the way, it will become clear that, in many ways, the implementation described only applies to embeddings, i.e. one-hot encodings, and not to to truly multi-dimensional variable inputs.&lt;/p&gt;
&lt;div id=&#34;the-transformerxl&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The TransformerXL&lt;/h2&gt;
&lt;div id=&#34;background&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;The previous part introduced a chronological introduction starting with RNNs. However, it would have been more accurate to present those models as Sequential Neural Network: They are concerned with dealing with sequential pieces of information (individual elements) and capturing their respective interactions. &lt;em&gt;Recurrent&lt;/em&gt; networks are but one type of sequential networks.&lt;/p&gt;
&lt;p&gt;The first generation Recurrent Neural Networks passes contextual information from one sequential unit to the next within a layer. A unit does not see anything past its preceding neighbour. Bidirectional networks do not feed a unit with information coming from both sides within a single layer, they are a combination of two layers going in opposite directions. RNNs do not capture information as a whole.&lt;/p&gt;
&lt;p&gt;The addition of &lt;em&gt;attention&lt;/em&gt; is the first mechanism that captured the entire sequence. First, within an RNN layer, each unit receives an input from the preceding layer (or a training segment). Then, an attention layer (an &lt;em&gt;attention head&lt;/em&gt;) is fed with each and every output produced by the RNN layer. Each hidden state is weighted by trained parameters and the attention layer produces
Several attention heads can be trained in parallel and combine their results using trained parameters into a final output.&lt;/p&gt;
&lt;p&gt;The number of parameters for this type of model is extremely large.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;compressive-memory&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Compressive Memory&lt;/h2&gt;
&lt;div id=&#34;background-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;From the last post, recall that compressive transformer are an extension to the TransformerXL. TransformerXL trains using segments extracted from all the sequences available in the dataset. It also uses hidden states calculated when training prior segments. In a sense, it seeks to indirectly increase the size of the training segments. Naturally, the model stores past hidden states (past memories) in a buffer of limited size. It has to discard discarding the oldest memories from that primary memory when moving from a segment to the next.&lt;/p&gt;
&lt;p&gt;The key addition of the compressive model is to avoid immediately the discarding by compressing those past states in a compressed representation (which itself will eventually be discarded). The training needs to cover the original TransformerXL and the quality of the compression mechanics. When training a typical network, the values of all the parameters are simultaneously optimised using the gradients calculated for each of those parameters. Instead, this model is trained as 2 separate models:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The Transformer-XL layers are trained using a current segment, and the primary and compressed memories to train the cells’ parameters (and only those!). During that stage, the compressed memory parameters is given as a constant: no gradients are calculated. Conceptually, this is the normal TransformerXL where the inputs are the concatenation of the segment embeddings and all the memories (primary and compressed).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Separately&lt;/em&gt;, another training process looks for an optimal compressed representation of past memories that would otherwise be discarded. Training the compression mechanism assumes that the transformer cells’ parameters are fixed and constant. This stage is only concerned with the efficiency of the representation. Note that certain compression mechanics, like pooling, have no parameters to optimise (although some hyperparameters might be involved).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;model-overall-structure&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Model overall structure&lt;/h3&gt;
&lt;p&gt;The authors describe the overall algorithm at a high level. We will retain the same notations, which are summarised at the end of of the post, but we will use a slightly different vocabulary. In particular, a &lt;em&gt;training set&lt;/em&gt; (for example a full text) is split into ordered &lt;em&gt;sequences&lt;/em&gt; that for a conceptual whole (a full sentence). Each sequence is fed into the model which has a limited number of inputs. If the size of a sequence is too large, it is split into &lt;em&gt;segments&lt;/em&gt;. The size of a segment is the number of input of the model. The key attraction of the compressive memory is to lengthen the memory of a TransformerXL: for an identical computation budget, the paper shows that it is valuable to shorten the segments (fewer self-attention heads), in exchange for keeping longer compressed past memories (the self-attention heads become larger to give attention to compressed memories).&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/post/2020-03-RNN-compressive-memory/Compressive-template.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;strong&gt;Compressive TransformerXL&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;To complete the notation, we use the following form of indices: &lt;span class=&#34;math inline&#34;&gt;\(h^{(l), v}_t\)&lt;/span&gt; which should be read as &lt;span class=&#34;math inline&#34;&gt;\(h^{(\text{Layer index}), \text{Segment index}}_{\text{Time step}}\)&lt;/span&gt;. In addition, &lt;span class=&#34;math inline&#34;&gt;\(h^{(1)}\)&lt;/span&gt; represents the inputs into the first layer, i.e. equals the current training segment &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: lower-alpha&#34;&gt;
&lt;li&gt;&lt;p&gt;The model starts with transformer layers (&lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; layers). (see step (a) on the diagram).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Each layer takes a number of entries (a segment of &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt; inputs), each being a vector of dimension &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;. Note that &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; is the dimension of the initial input embeddings, and of all input/output vectors of further layers. This could however be a flexible model parameter.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Each individual transformer layer has an identical structure with the same number of self-attention heads (&lt;span class=&#34;math inline&#34;&gt;\(n_{head}\)&lt;/span&gt; heads). Recall that an attention head is a triplet of matrices &lt;span class=&#34;math inline&#34;&gt;\((W^{(i)}_q, W^{(i)}_k, W^{(i)}_v)\)&lt;/span&gt; and a multi-layer perceptron. &lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At each iteration, the self-attention heads are trained using the outputs from the previous layer, and primary and compressed memories.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After an input is processed by a layer, it is pushed into memory. The memory size &lt;span class=&#34;math inline&#34;&gt;\(n_m\)&lt;/span&gt; has the capacity to store a number &lt;span class=&#34;math inline&#34;&gt;\(n_{slots}\)&lt;/span&gt; of segments. Therefore &lt;span class=&#34;math inline&#34;&gt;\(n_m = n_{slots} \times n_s\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The new memory pushes the oldest one out, which is compressed into a compressed memory with a &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; compression ratio. the compressed memory can hold &lt;span class=&#34;math inline&#34;&gt;\(n_{old}\)&lt;/span&gt; compressed memories. &lt;span class=&#34;math inline&#34;&gt;\(n_{cm}\)&lt;/span&gt; is a multiple of &lt;span class=&#34;math inline&#34;&gt;\(n_{old}\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;memory-compression&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Memory compression&lt;/h2&gt;
&lt;p&gt;Let’s focus on Step (f). The compression mechanics are optimised independently from the TransformerXL layers and require choosing a compression scheme (function &lt;span class=&#34;math inline&#34;&gt;\(f_c\)&lt;/span&gt;) and, if there are parameters to be trained, a loss function to minimise.&lt;/p&gt;
&lt;div id=&#34;compression-function&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Compression function&lt;/h3&gt;
&lt;p&gt;The authors reviewed several choices for the function &lt;span class=&#34;math inline&#34;&gt;\(f^{(i)}_c\)&lt;/span&gt;.&lt;/p&gt;
&lt;div id=&#34;pooling&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Pooling&lt;/h4&gt;
&lt;p&gt;The simplest is &lt;em&gt;Max and/or mean pooling&lt;/em&gt;, where the kernel and stride is set to the compression rate c. This is fast, requires no training (no parameters) and was used as a simple baseline.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;convolution&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Convolution&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;1D-convolution&lt;/em&gt; also with kernel and stride set to c. This is defined by parameters which require training.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;dilated-convolution&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Dilated convolution&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Dilated convolutions&lt;/em&gt; which were proposed in 2016 as an alternative to traditional image convolution (for image classification) when dealing with semantic networks. See &lt;a href=&#34;https://arxiv.org/abs/1511.07122&#34;&gt;Multi-Scale Context Aggregation by Dilated Convolutions&lt;/a&gt;. In essence, dilated convolutions are large scale convolutions (large kernel) defined with the same number of parameters as a small kernel. They are better suited to capture distant relationships present in semantic networks.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;most-used-compression&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Most-used compression&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Most-used&lt;/em&gt; compression where the memories are sorted by their average attention(usage) and the most-used are preserved. The most-used compression scheme is inspired from the garbage collection mechanism in the Differentiable Neural Computer (&lt;em&gt;DNC&lt;/em&gt;) where low-usage memories are erased. This is described in the 2016 DeepMind paper &lt;a href=&#34;https://www.gwern.net/docs/rl/2016-graves.pdf&#34;&gt;Hybrid computing using a neural network with dynamic external memory&lt;/a&gt;. A DNC is network augmented with memory, where a controller can read and write memory banks. The DNC article is very detailed on the technical aspects. We understand that most-used algorithm is presented in appendix under the &lt;em&gt;Dynamic memory allocation&lt;/em&gt; subsection.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;auto-encoders&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Auto-encoders&lt;/h4&gt;
&lt;p&gt;As we understand, the authors did not consider auto-encoding networks with &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; fewer parameters. It might be that they were considered but rejected.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;compression-ratio&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Compression ratio&lt;/h4&gt;
&lt;p&gt;If the compression ratio is &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;, what are the dimensions of the compressed memory tensors?&lt;/p&gt;
&lt;p&gt;The paper leaves this unspecified.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pooling and 1D-convolution will produce tensors where the dimension of the attention heads (along the &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; axis) are divided by &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Our understanding of the most-used algorithm would be to zero all values save for a &lt;span class=&#34;math inline&#34;&gt;\(1 / c\)&lt;/span&gt; proportion, but retaining identical dimensions.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;However, we do not see &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; memory attention heads compressed into a single vector (compression along the &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt; axis).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;loss-function&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Loss function&lt;/h3&gt;
&lt;p&gt;Several loss functions were considered.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;A whole-model optimisation where all parameters (compression mechanics + TransformerXL Layers) are trained at once using the training set error. However they found the size overwhelming, especially when old compressed memories were unrolled into full-form memories. They then used &lt;em&gt;backpropagating-through-time&lt;/em&gt; (BPTT), which by definition does not do full-model optimisation to avoid vanishing/exploding gradients. See &lt;a href=&#34;https://d2l.ai/chapter_recurrent-neural-networks/bptt.html&#34;&gt;BPTT&lt;/a&gt; for a good overview. Note that this is not what we introduced as a two-step optimisation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The compression is a form of representation learning / auto-encoding which optimises an encoder (presumably &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; fewer parameters) by simultaneously training a decoder. The paper tried a &lt;span class=&#34;math inline&#34;&gt;\(\mathcal{L}_2\)&lt;/span&gt; (square) error on the ability to reconstruct the memory tensors. It does not go into detail aside from mentioning it. The posts will not explore this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The paper goes into more detail about the two-step training of an &lt;em&gt;attention-reconstruction loss&lt;/em&gt;. Transformers optimise attention parameters (the attention head matrices). Optimising for the ability of retaining that information makes complete sense. This loss function is the &lt;span class=&#34;math inline&#34;&gt;\(\mathcal{L}_2\)&lt;/span&gt; error between the attention matrix of a memory slot and reconstructed attention. Next section focuses on the loss function.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;model-timing&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Model timing&lt;/h3&gt;
&lt;p&gt;Let’s be clearer about the details of what takes place as time goes by (as segments are presented) and how the compression optimisation proceeds (at the risk of being repetitive).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The set of the model’s state vectors (the &lt;span class=&#34;math inline&#34;&gt;\(h^{(i)}\)&lt;/span&gt;) is the model’s reaction to a particular input. They are an immediate reaction to an current input. They reflect the values of the current attention heads’ parameters.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A memory slot is a set of a layer’s state vectors created in the past for a past input when the model’s parameters were different.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; It is the past model’s reaction to something that happened in the past (the input at that time).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That memory slot reflects the experience of the model at that time (the attention heads parameters). Since then, the model has been trained further. The recent updated model would have yielded a different set of state vectors for that past input.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Attention heads are not state vectors. They are functions to be trained.&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; Those functions, for any input state vectors, will produce a different answer, a different set of state vectors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Attention heads are trained and after training they will eventually be constants. However, the the state vectors will change as and when the inputs do.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The compression is also a function that will be frozen after training which will use (if it relies on parameters).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those precisions are relevant because a compression takes place now (i.e. at the time of a current segment). It is applied to a past memory which reflects a past reaction to a past input with a past model. We optimise compression parameters &lt;em&gt;now&lt;/em&gt; using values and parameters that are all from the past.&lt;/p&gt;
&lt;p&gt;Optimising for attention reconstruction means:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Right now, the model gives a particular set of current state vectors for a given current input.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This model has a past memory that is about to be lost (as in a normal TransformerXL).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In this model, the old memory is about to be compressed. If compressed, the original memory could be reconstructed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If the compression (and reconstruction) algorithm is perfect, it should not matter whether the compressed memory (after reconstruction) or the old memory is used.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The optimisation is therefore to minimise the difference what the model does with the past memory (not yet discarded) and what would happen if the past memory was reconstructed from its compressed form.&lt;/p&gt;
&lt;p&gt;The difference between the 2 situations is the loss function to be minimised. Transformers are about attention; the compression algorithm is judged by its ability to retain past attention (what was worthy of attention in the past).&lt;/p&gt;
&lt;p&gt;As the paper indicates, this is a lossy objective. The reconstruction is not optimised to replicate the old memory. It is instead optimised to reconstruct an &lt;em&gt;alternative memory&lt;/em&gt; that gives a better reconstruction of the attentions. The paper asserts that this gives superior results to the reconstruction of the memory. Keeping in mind that the ultimate purpose of the model is to optimise self-attentions, possible explanations are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memories are used as input into the attention heads to determine the self-attention. So will a reconstructed memory. Therefore, primary memory reconstruction errors are then compounded with the modelling errors of the attention heads’ matrices. Skipping the intermediary avoids this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Maybe more interesting, the past memory is mechanically imperfect: it is based on old model parameters. Optimising the reconstruction to reproduce an imperfect memory implicitly means incorporating attention heads’ parameters that were used at the time the memory was created. The reconstructed memory includes the errors of the past attention heads which have since been reduced (hopefully). In other words, the reconstructed memory is an &lt;em&gt;alternative memory&lt;/em&gt; which might include later corrections to the model attention heads.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;attention-reconstruction-loss&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Attention-Reconstruction Loss&lt;/h3&gt;
&lt;p&gt;For sake of completeness, we include the &lt;em&gt;attention-reconstruction loss&lt;/em&gt; algorithm detailed in the paper (&lt;em&gt;Algorithm 2&lt;/em&gt; on page 4). &lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Its overall organisation is independent from the actual loss calculation (the stop-gradient mechanics), therefore remains of value. It is replicated here with slight modifications for type consistency. Note that at Step 6 the published algorithm uses a &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;. This could suggest that a sigmoid activation is used, but it would make no sense to compare attentions calculated with different activation functions (&lt;span class=&#34;math inline&#34;&gt;\(softmax\)&lt;/span&gt; in the layers vs. &lt;span class=&#34;math inline&#34;&gt;\(sigmoid\)&lt;/span&gt; in the the reconstruction).&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{array}{ll}
&amp;amp; \textit{Reset the attention loss} \\
&amp;amp; \hline \\
1: &amp;amp; \mathcal{L} \leftarrow 0 \\
\\
&amp;amp; \textit{Main Loop} \\
&amp;amp; \hline \\
&amp;amp; \text{Now that the loss is reset, loop through the layers, one at a time} \\
2: &amp;amp; \textit{for layer }i = 1, 2, \cdots , l \textit{ do} \\
\\
&amp;amp; \textit{Stop all gradients for anything but the compression function parameters} \\
&amp;amp; \hline \\
&amp;amp; \text{TensorFlow uses stop_gradient()} \\
&amp;amp; \text{PyTorch uses .detach()} \\
&amp;amp; \text{We&amp;#39;ll use DetachGradient() to make both happy!} \\
3:  &amp;amp;  DetachGradient(h^{(i)}) \\
4:  &amp;amp;  DetachGradient(M^{(i)}_{t-n_{slots}}) \text{ --- oldest Primary memory slot about to be discarded}  \\
5:  &amp;amp;  DetachGradient(Q, K, V) \text{ --- parameters of all the attention heads matrices}  \\
\\
&amp;amp; \textit{Define the content-based attention being the same calculation as inside the layers}\\
&amp;amp; \hline \\
6: &amp;amp;   Attention(h, m) \leftarrow softmax((hQ).(mK))(mV)  \\
\\
&amp;amp; \textit{Calculate the new compressed memory}\\
&amp;amp; \hline \\
7: &amp;amp;   CM^{(i)}_{1} \leftarrow f^{(i)}_c(M^{(i)}_{t-n_{slots}})   \\
\\
&amp;amp; \textit{Calculate a reconstructed attention from the proposed compressed memory}\\
&amp;amp; \hline \\
7: &amp;amp;   R^{(i)} \leftarrow Reconstruction(CM^{(i)}_{1})  \\
\\
&amp;amp; \textit{Update the loss for the loss at the current layer}\\
&amp;amp; \hline \\
8: &amp;amp;   \mathcal{L} \leftarrow \mathcal{L} + \left| Attention(h^{(i)}, M^{(i)}_{t-n_{slots}}) - Attention(h^{(i)}, R^{(i)}) \right|_2 \\
\\
&amp;amp; \hline \\
&amp;amp; \textit{End loop} \\
&amp;amp; \hline \\
\end{array}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This post presents the &lt;em&gt;Compressive Transformers&lt;/em&gt; in more details, including the articulation between training the attention heads and training the compression mechanics.&lt;/p&gt;
&lt;p&gt;To come in part 3, the code.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;notation-summary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Notation summary&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Size parameters&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{array}{ll}
l:        &amp;amp;   \text{number of layers, starting from 1} \\
d:        &amp;amp;   \text{dimension of all input (including embeddings) AND output vectors passed from a layer to the next} \\
n_{head}: &amp;amp;   \text{number of self-attention heads in a TransformerXL layer} \\
n_s:      &amp;amp;   \text{size of a training segment = number of inputs into and outputs from a layer} \\
s = n_s:  &amp;amp;   s \text{ will be used as index name to represent the input dimension when using named tensors,}  \\
&amp;amp; \text{i.e. Einstein summation.}  \\
b:        &amp;amp;   \text{size of a training batch, i.e. number of segments in a batch. Used in named tensors as well} \\
\\
n_m:      &amp;amp;   \text{number of hidden states kept in the primary memory. n_m is a multiple of n_s} \\
c:        &amp;amp;   \text{memory compression ratio} \\
n_{cm}:   &amp;amp;   \text{number of states kept in the compressed memory. n_{cm} }  \\
\end{array}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;We only consider a wide self-attention model, in part having in mind the application to time series where we will work with embeddings of smaller size. We therefore ignore the narrow self-attention model variant.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;We ignore the possible impact of training in batches.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;We ignore the multi-perceptrons.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;Forgive the algorithm formatting. R markdown resisted naive efforts to use Latex algorithms.&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>RNN Compressive Memory Part 2: The TransformerXL</title>
      <link>/2020/12/30/rnn-compressive-memory-part-2-the-transformerxl.html</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/2020/12/30/rnn-compressive-memory-part-2-the-transformerxl.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#the-transformerxl&#34;&gt;The TransformerXL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#algorithm-for-a-single-layer-with-matrix-dimension&#34;&gt;Algorithm for a single layer with matrix dimension&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notation-summary&#34;&gt;Notation summary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#useful-references&#34;&gt;Useful references&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;This is part 2 of a discussion of the DeepMind paper about &lt;a href=&#34;https://arxiv.org/abs/1911.05507&#34;&gt;Compressive Transformers for Long-Range Sequence Modelling&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;../../03/07/rnn-compressive-memory-part-1.html&#34;&gt;Part 1&lt;/a&gt;: A high level introduction to Compressive Memory mechanics starting from basic RNNS;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 2 (here): more details about the TransformerXL;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 3: an implementation using PyTorch (soon);&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 4: finally, its application to time series (soon).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post describes the building blocks up to what makes a &lt;a href=&#34;https://arxiv.org/abs/1901.02860&#34;&gt;TransformerXL&lt;/a&gt; model as presented in June 2019. The compression mechanics are an add-on to the TransformerXL which therefore need to be detailed. Along the way, it will become clear that, in many ways, the implementation described only applies to embeddings, i.e. one-hot encodings, and not to to truly multi-dimensional variable inputs.&lt;/p&gt;
&lt;div id=&#34;the-transformerxl&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The TransformerXL&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{array}{l}
\text{Notation:} &amp;amp; \\
\tau &amp;amp; \text{time step or index on successive segments} \\
b &amp;amp; \text{batch size} \\
h &amp;amp; \text{number of heads} \\
s_s &amp;amp; \text{length of a segment} \\
s_m &amp;amp; \text{length of the memory} \\
s = s_m + s_s &amp;amp; \text{length of segment + memory} \\
d &amp;amp; \text{size of an embedding} \\
d_{in} &amp;amp; \text{size of the embedding as input to a given layer} \\
d_{out} &amp;amp; \text{size of the embedding as output from a given layer} \\
(b, h, s, d): &amp;amp; \text{tensor of 4 dimension reflecting those dimensions}\\
l &amp;amp; \text{index of a layer} \\
\end{array}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The number of parameters for this type of model is extremely large.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;algorithm-for-a-single-layer-with-matrix-dimension&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Algorithm for a single layer with matrix dimension&lt;/h2&gt;
&lt;p&gt;The implementation will use the &lt;a href=&#34;https://pytorch-lightning.readthedocs.io/en/latest/&#34;&gt;Pytorch Lightning&lt;/a&gt; library. The entire code is on &lt;a href=&#34;https://github.com/Emmanuel-R8/Time_Series_Transformers&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import sys
import inspect

from typing import *

import torch
import torch.nn as nn

from pytorch_lightning.core.lightning import LightningModule

from utils.exp_utils import logging&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# From https://github.com/harvardnlp/annotated-transformer
class PositionalEncoding(LightningModule):
    &amp;quot;Implement the edited PE function, depends on sequence length rather than input dimensionnality.&amp;quot;

    def __init__(self, runParam, dropout=0.1):
        super().__init__()
        self.dropout = nn.Dropout(p=dropout)
        
        batch

        # Compute the positional encodings once in log_2 space ceiled to sequence_length.
        b = math.ceil(math.log(max_sequence_length * 4, 2))
        a = int(2**b / 4)  # Up to a quarter of a sine wave
        x1 = np.array([[math.cos(0.5**i*x*2*math.pi) for x in range(max_sequence_length, 0, -1)] for i in range(1, b+1)])
        x2 = np.array([[math.sin(0.5**i*x*2*math.pi) for x in range(max_sequence_length, 0, -1)] for i in range(2, b+2)])
        x = np.concatenate([x1, x2], axis=0)
        print(&amp;quot;x.shape():&amp;quot;, x.shape)
        x = np.expand_dims(x, 0).repeat(repeats=batch_size, axis=0)
        print(&amp;quot;x.shape():&amp;quot;, x.shape)

        # Register it into PyTorch
        pe = torch.from_numpy(x).float()
        pe = pe.transpose(-1, -2)
        print(&amp;quot;pe.size():&amp;quot;, pe.size())
        self.register_buffer(&amp;#39;pe&amp;#39;, pe)

    def forward(self, x):
        pos = Variable(self.pe, requires_grad=False)
        # print(pos.size(), x.size())  # [batch_size, -1, sequence_length], [batch_size, sequence_length, hidden_size]
        pe = self.pe[:, -x.size(1):]  # limiting positional encoding to a poentially shorter sequence_length
        print(&amp;quot;pe.size(), x.size():&amp;quot;, pe.size(), x.size())
        x = torch.cat([x, pe], dim=-1)
        return self.dropout(x), pos&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{array}{l}
\text{Step for a} &amp;amp; &amp;amp; \text{Dimensions for multiple layers} \\
\text{single layer} &amp;amp; &amp;amp; \text{(with Einstein summation)} \\
\hline \\
h^{l-1}_\tau &amp;amp; &amp;amp; (l, h, s_s, d_{in}) \\
\hline \\
\tilde{h}^{l-1}_\tau = &amp;amp; \left[ StopGradient(m^{l-1}_\tau) \circ  h^{l-1}_\tau \right]  &amp;amp; (l, h, s, d_{in}) = (l, h, s_m, d_{in}) \circ (l, h, s_s, d_{in}) \\
\hline \\
q^l_\tau = &amp;amp; h^{l-1}_\tau \cdot {W^l_Q}^\top &amp;amp; (l, h, s_s, d_{in}) = (l, h, s_s, d_{in}) \dot {(l, h, d_{in}, d_{in})}^\top \\
&amp;amp; &amp;amp; lhsd_1,lhsd_1d_2 \rightarrow lhsd_2 \\
\hline \\
k^l_\tau = &amp;amp; \tilde{h}^{l-1}_\tau \cdot {W^l_K}^\top &amp;amp; (l, h, s, d_{in}) = (l, h, s, d_{in}) \dot {(l, h, d_{in}, d_{in})}^\top \\
&amp;amp; &amp;amp; lhsd_1,lhsd_1d_2 \rightarrow lhd_2 \\
\hline \\
v^l_\tau = &amp;amp; \tilde{h}^{l-1}_\tau \cdot {W^l_V}^\top &amp;amp; (l, h, s, d_{in}) = (l, h, s, d_{in}) \dot {(l, h, d_{in}, d_{in})}^\top \\
&amp;amp; &amp;amp; lhsd_1,lhsd_1d_2 \rightarrow lhd_2 \\
\hline \\
A^l_\tau = &amp;amp; {Q^l}^\top \dot \\
\end{array}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;notation-summary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Notation summary&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Size parameters&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{array}{ll}
l:        &amp;amp;   \text{number of layers, starting from 1} \\
d:        &amp;amp;   \text{dimension of all input (including embeddings) AND output vectors passed from a layer to the next} \\
n_{head}: &amp;amp;   \text{number of self-attention heads in a TransformerXL layer} \\
n_s:      &amp;amp;   \text{size of a training segment = number of inputs into and outputs from a layer} \\
s = n_s:  &amp;amp;   s \text{ will be used as index name to represent the input dimension when using named tensors,}  \\
&amp;amp; \text{i.e. Einstein summation.}  \\
b:        &amp;amp;   \text{size of a training batch, i.e. number of segments in a batch. Used in named tensors as well} \\
\\
n_m:      &amp;amp;   \text{number of hidden states kept in the primary memory. n_m is a multiple of n_s} \\
c:        &amp;amp;   \text{memory compression ratio} \\
n_{cm}:   &amp;amp;   \text{number of states kept in the compressed memory. n_{cm} }  \\
\end{array}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;useful-references&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Useful references&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nlp.seas.harvard.edu/2018/04/03/attention.html&#34;&gt;The Annotated Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fromkk.com/posts/the-annotated-the-annotated-transformer/&#34;&gt;The Annotated The Annotated Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://d2l.ai/chapter%5Fattention-mechanisms/transformer.html&#34;&gt;Dive into Deep Learning - 10.3 Transformer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Normalising Flows and Neural ODEs</title>
      <link>/2020/08/14/normalising-flows.html</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
      <guid>/2020/08/14/normalising-flows.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/d3/d3.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/dagre/dagre-d3.min.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/mermaid/dist/mermaid.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/mermaid/dist/mermaid.slim.min.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/chromatography/chromatography.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/DiagrammeR-binding/DiagrammeR.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#a-few-words-about-generative-models&#34;&gt;A few words about Generative Models&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#latent-variables&#34;&gt;Latent variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#examples-of-generative-models&#34;&gt;Examples of generative models&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#generative-adversarial-networks-gans&#34;&gt;Generative Adversarial Networks (&lt;strong&gt;GANS&lt;/strong&gt;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#variational-autoencoders&#34;&gt;Variational autoencoders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#normalising-flows&#34;&gt;Normalising flows&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction-1&#34;&gt;Introduction&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#some-math&#34;&gt;Some math&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#training-loss-optimisation-and-information-flow&#34;&gt;Training loss optimisation and information flow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#basic-flows&#34;&gt;Basic flows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#planar-flows&#34;&gt;Planar Flows&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#radial-flows&#34;&gt;Radial flows&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#more-complex-flows&#34;&gt;More complex flows&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#residual-flows-discrete-flows&#34;&gt;Residual flows (discrete flows)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#other-versions&#34;&gt;Other versions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#continuous-flows&#34;&gt;Continuous flows&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#neural-ordinary-differential-equations&#34;&gt;Neural ordinary differential equations&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#continuous-flows-1&#34;&gt;Continuous flows&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#continuous-flows-means-no-crossover&#34;&gt;Continuous flows means no-crossover&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#universal-ordinary-differential-equations&#34;&gt;Universal ordinary differential equations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stochastic-differential-equations&#34;&gt;Stochastic differential equations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#other&#34;&gt;Other&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optimisation&#34;&gt;Optimisation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#references&#34;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;li class=&#34;appendix&#34;&gt;&lt;span&gt;&lt;b&gt;Appendix&lt;/b&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#more-information&#34;&gt;More information&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#one-more-thing&#34;&gt;One more thing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;One of the three best papers awarded at NIPS 2018 was &lt;em&gt;Neural Ordinary Differential Equations&lt;/em&gt; by Tian Qi Chen, Yulia Rubanova, Jesse Bettencourt and David Duvenaud &lt;span class=&#34;citation&#34;&gt;(Chen et al. &lt;a href=&#34;#ref-chenNeuralOrdinaryDifferential2019&#34; role=&#34;doc-biblioref&#34;&gt;2019&lt;/a&gt;)&lt;/span&gt;. Since then, the field has developed in multiple directions. This post goes through some background about generative models, normalising flows and finally a few of the underlying ideas of the paper. The form does not intend to be mathematically rigorous but convey some intuitions.&lt;/p&gt;
&lt;div id=&#34;a-few-words-about-generative-models&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;A few words about Generative Models&lt;/h1&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Generative models&lt;/strong&gt; are about learning simple &lt;strong&gt;representations&lt;/strong&gt; of a complex datasets; how to, from a few parameters, generate realistic samples that are similar to a given dataset. Those few parameters usually follow simple distributions (e.g. uniform or Gaussian), and are transformed through complex transformations into the more complex dataset distribution. This is an unsupervised procedure which, in a sense, mirrors clustering methods: clustering starts from the dataset and summarises it into few parameters.&lt;/p&gt;
&lt;p&gt;[DIAGRAM var 1D to another var 1D]&lt;/p&gt;
&lt;p&gt;[DIAGRAM var 1D to another var 2D]&lt;/p&gt;
&lt;p&gt;Although unsupervised, the result of this learning can be used as a &lt;strong&gt;pretraining&lt;/strong&gt; step in a later supervised context, or where that dataset is a mix of labelled and un-labelled data. The properties of the well-understood starting probability distributions can then help draw conclusions about the dataset’s distribution or generate synthetic datasets.&lt;/p&gt;
&lt;p&gt;The same methods can also be used in supervised learning to learn the representation of a target dataset (categorical or continuous) as a transformation of the features dataset. The unsupervised becomes supervised.&lt;/p&gt;
&lt;p&gt;What does &lt;em&gt;representation learning&lt;/em&gt; actually mean? It is the automatic search for a few parameters that encapsulate rich enough information to generate a dataset. Generative models learn those parameters and, starting from them, how to re-create samples similar to the original dataset.&lt;/p&gt;
&lt;p&gt;Let’s use cars as an analogy.&lt;/p&gt;
&lt;p&gt;All cars have 4 wheels, an engine, brakes, seats. One could be interested in comfort or racing them or lugging things around or safety or fitting as many kids as possible. Each base vector could be express any one of those characteristics, but they will all have an engine, breaks and seats. The generation function recreates everything that is common. It doesn’t matter if the car is comfy or not; it needs seats and a driving wheel. The generative function has to create those features. However, the exact number of cylinders, its shape, the seats fabric, or stiffness of the suspension all depend on the type of car.&lt;/p&gt;
&lt;p&gt;The tru fundamentals are not obvious. For a long time, American cars had softer suspension than European cars. The definition of comfortable is relative. The performance of an old car is objectively not the same as compared to new ones. Maybe other characteristics are more relevant to generate. Maybe price? Consumption? Year of coming to market? All those factors are obviously inter-related.&lt;/p&gt;
&lt;p&gt;Generative models are more than generating samples from a few fundamental parameters. They also learn what those parameters should be.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;latent-variables&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Latent variables&lt;/h2&gt;
&lt;p&gt;Still using the car analogy, if the year of a model was not given, the generative process might still be able to conclude that the model year &lt;em&gt;should&lt;/em&gt; be an implicit parameter to be learned since relevant to generate the dataset: year is an unstated parameter that explains the dataset. Both the Lamborghini Miura and Lamborghini Countach&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; were similar in terms of perceived performance and exclusivity at the time they were created. But actual performances and styling where incredibly different.&lt;/p&gt;
&lt;p&gt;If looking at the stock market: take a set of market prices at a given date; it would have significantly different meanings in a bull or a bear market. Market regime would be a reasonable latent variable.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;examples-of-generative-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Examples of generative models&lt;/h2&gt;
&lt;p&gt;There are quite a number of generative models such restricted Boltzmann machines, deep belief networks. Refer to &lt;span class=&#34;citation&#34;&gt;(Theodoridis &lt;a href=&#34;#ref-theodoridisMachineLearningBayesian2020&#34; role=&#34;doc-biblioref&#34;&gt;2020&lt;/a&gt;)&lt;/span&gt; and &lt;span class=&#34;citation&#34;&gt;(Russell and Norvig &lt;a href=&#34;#ref-russellArtificialIntelligenceModern2020&#34; role=&#34;doc-biblioref&#34;&gt;2020&lt;/a&gt;)&lt;/span&gt; for example. Let’s consider generative adversarial networks and variational auto-encoders.&lt;/p&gt;
&lt;div id=&#34;generative-adversarial-networks-gans&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Generative Adversarial Networks (&lt;strong&gt;GANS&lt;/strong&gt;)&lt;/h3&gt;
&lt;p&gt;Recently, GANs have risen to the fore as a way to generate artificial datasets that are, for some definition, indistinguishable from a real dataset. They consist of two parts:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Editor at 
# https://mermaid-js.github.io/mermaid-live-editor
DiagrammeR::mermaid(&amp;quot;GAN.mmd&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;htmlwidget-1&#34; style=&#34;width:672px;height:480px;&#34; class=&#34;DiagrammeR html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-1&#34;&gt;{&#34;x&#34;:{&#34;diagram&#34;:&#34;\ngraph LR\n\n  subgraph Generative Model\n    Representation[\&#34;Representation &lt;br/&gt; (latent space)\&#34;] --&gt; Generator[&lt;b&gt;Generator&lt;\/b&gt;]\n  end\n\n  Generator--&gt; Discriminator[&lt;b&gt;Discriminator&lt;\/b&gt;]\n\n  Sample\n\n  Sample[Sample] --&gt; Discriminator\n\n  Discriminator --&gt; ID[Identification as &lt;br/&gt; generated or true]\n\n  ID -.-&gt;|Feedback| Discriminator\n  ID -.-&gt;|Feedback| Generator&#34;},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A generator which is the generative model itself: given a simple representation, the generator proposes samples that aim to be undistinguishable from the dataset sample.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A discriminator whose job is to identify whether a sample comes from the generator or from the dataset.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both are trained simultaneously:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;if the discriminator finds it obvious to guess, the generator is not doing a good job and needs to improve;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;if the discriminator guesses 50/50 (does not do better than flipping a coin), it has to discover which true dataset features are truly relevant.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;variational-autoencoders&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Variational autoencoders&lt;/h3&gt;
&lt;p&gt;A successful GAN can replicate the richness of a dataset, but not the its distribution. A GAN can generate a large number of correct sentences, but will not tell how likely to occur that sentence is (or at least guarantee that the distributions match). &lt;em&gt;‘The dog chases the cat’&lt;/em&gt; and &lt;em&gt;‘The Chihuahua chases the cat’&lt;/em&gt; are both perfectly valid, but the latter less unlikely to appear.&lt;/p&gt;
&lt;p&gt;Variable autoencoders (VAEs) take another approach by learning a generator (called &lt;em&gt;decoder&lt;/em&gt;) &lt;em&gt;and&lt;/em&gt; learning the distribution of the parameters to reflect the distribution of the samples within the dataset (the &lt;em&gt;encoder&lt;/em&gt;). Both are trained simultaneously on the dataset samples by projecting samples on the latent variables’ space, proposing a generated sample from that projection and training on the reconstruction loss. The encoder actually learns means and standard deviations of the each latent variable, wach being a normal distribution. The samples generated will be as rich as the GAN’s, but the probability of a sample being generated will depend on the learned distributions.&lt;/p&gt;
&lt;p&gt;See &lt;span class=&#34;citation&#34;&gt;(Kingma and Welling &lt;a href=&#34;#ref-kingmaIntroductionVariationalAutoencoders2019&#34; role=&#34;doc-biblioref&#34;&gt;2019&lt;/a&gt;)&lt;/span&gt; for an approachable extensive introduction. The details of VAEs include implementation aspects (in particular the &lt;em&gt;reparametrization trick&lt;/em&gt;) that are critical to the success of this approach.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;limitations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Limitations&lt;/h2&gt;
&lt;p&gt;We limited the introduction to those two techniques to merely highlight two fundamental aspect that generative models aim at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;explore and replicate the richness of the dataset;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;replicate the probability distribution of the dataset.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that depending on the circumstances, the latter aim may not necessarily be important.&lt;/p&gt;
&lt;p&gt;As usual, training and optimisation methods are at risk of getting stuck at local optima. In the case of those two techniques, this manifests itself in different ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;GANs Mode collapse&lt;/em&gt;: Mode collapse occurs in GANs when the generator only explores limited domains. Imagine training a GAN to recognise mammals (the dataset would contain kangaroos, whales, dogs and cats…). If the generator proposes everything but kangoaroos, it is still properly generate mammals, but obviously misses out on a few possibilities. Essentially, the generator reaches a local minimum where the gradient becomes too small to explore alternatives. This is in part due to the difficulty of progressing the training of both the generator and the discriminator in a way that does not lock any one of them in a local optimum while the other still needs improving: if either converges too rapidly, the other will struggle improving.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;VAEs Posterior collapse&lt;/em&gt;: Posterior collapse in VAEs arises when the generative model learns to ignore a subset of the latent variables (although the encoder generates those variables) &lt;span class=&#34;citation&#34;&gt;(Lucas et al. &lt;a href=&#34;#ref-lucasDonBlameELBO2019&#34; role=&#34;doc-biblioref&#34;&gt;2019&lt;/a&gt;&lt;a href=&#34;#ref-lucasDonBlameELBO2019&#34; role=&#34;doc-biblioref&#34;&gt;b&lt;/a&gt;)&lt;/span&gt;. More technically, it happens when the variational distribution closely matches the uninformative prior for a subset of latent variables &lt;span class=&#34;citation&#34;&gt;(Lucas et al. &lt;a href=&#34;#ref-lucasUnderstandingPosteriorCollapse2019&#34; role=&#34;doc-biblioref&#34;&gt;2019&lt;/a&gt;&lt;a href=&#34;#ref-lucasUnderstandingPosteriorCollapse2019&#34; role=&#34;doc-biblioref&#34;&gt;a&lt;/a&gt;)&lt;/span&gt;. The exact reasons for this are not entirely understood and this remains an active area of research (refer this extensive list of &lt;a href=&#34;https://github.com/sajadn/posterior-collapse-list&#34;&gt;papers&lt;/a&gt; on the topic).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As we will see, normalising flows address those two difficulties. Intuitively:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mode collapse reflects that the generative process does not generate enough possibilities; that the spectrum of possibilities is not as rich as that of the dataset. Normalising flows attempt to address this in two ways. Firstly, the optimising process aims as optimising (and matching) the amount of generated information to that of the dataset. Secondly, normalising flows allow to start from a sample in the dataset, flow back to the simple distribution and estimate how (un)likely the generative model would have generated this sample. If the dataset has a lot of whales, generating only dogs is clearly not good enough…&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The posterior collapse could simply be a mismatch between the number of latent variables and the dimensionality of the dataset, difficulties to specify an effective loss function (and its gradients) or a local optima. As we will see, normalising flows impose that the generative model be a bijection. In a sense, this means that there should be the same ‘complexity’ in the latent variables as in the dataset (although not the same amount of information in the sense of information theory).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;!–&amp;gt;
## &lt;strong&gt;CHECK FOLLOWING&lt;/strong&gt; Revival of neural networks&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In this section, the discussion setting is to learn representations that are independent of a specific
target task; the goal is to extract such information using the input data only. The reason for such a focus
is twofold. First, learning a model representation of the input data can be used subsequently in different
tasks in order to facilitate the training. Sometimes, this is also known as pretraining, where parameters
learned using unlabeled data can be used as initial estimates of the parameters for another supervised
learning. This can be useful when the number of labeled examples is not large enough (see, e.g., [148]
for a discussion). It is worth pointing out that such a pretraining rationale is of a historical importance,
because it led to the revival of neural networks, as will be discussed soon [86].&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;86 is &lt;span class=&#34;citation&#34;&gt;(“A Fast Learning Algorithm for Deep Belief Nets” &lt;a href=&#34;#ref-FastLearningAlgorithm2006&#34; role=&#34;doc-biblioref&#34;&gt;2006&lt;/a&gt;)&lt;/span&gt; from Bengio&lt;/p&gt;
&lt;p&gt;&amp;lt;!–&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;All methodology involve finding a function &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;. Neural networks have long been known to be able to generate artificially complicated functions and the idea of using them as a way to represent &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is one of the reasons that led to their revivals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;normalising-flows&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Normalising flows&lt;/h1&gt;
&lt;p&gt;Normalising Flows became popular around 2015 with two papers on density estimation &lt;span class=&#34;citation&#34;&gt;(Dinh, Krueger, and Bengio &lt;a href=&#34;#ref-dinhNICENonlinearIndependent2015&#34; role=&#34;doc-biblioref&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt; and use of variational inference &lt;span class=&#34;citation&#34;&gt;(Rezende and Mohamed &lt;a href=&#34;#ref-rezendeVariationalInferenceNormalizing2016&#34; role=&#34;doc-biblioref&#34;&gt;2016&lt;/a&gt;)&lt;/span&gt;. However, the concepts predated those papers. (See &lt;span class=&#34;citation&#34;&gt;(Kobyzev, Prince, and Brubaker &lt;a href=&#34;#ref-kobyzevNormalizingFlowsIntroduction2020a&#34; role=&#34;doc-biblioref&#34;&gt;2020&lt;/a&gt;)&lt;/span&gt; and &lt;span class=&#34;citation&#34;&gt;(Papamakarios et al. &lt;a href=&#34;#ref-papamakariosNormalizingFlowsProbabilistic2019&#34; role=&#34;doc-biblioref&#34;&gt;2019&lt;/a&gt;)&lt;/span&gt; for recent survey papers.)&lt;/p&gt;
&lt;div id=&#34;introduction-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;One important limitations of the approaches described above is that the generation flow is unidirectional: one starts from a source distribution, sometimes with well-known properties, and generates a richer target distribution. However, given a particular sample in the target distribution, there is no guaranteed way to identify where it would fall in the original source distribution. That flow of transformation from source to target is not guaranteed to be bijective or invertible (same meaning, different crowds). (In the case of VAEs, this is the case in the encoder.)&lt;/p&gt;
&lt;p&gt;Normalising flows are a generic solution to that issue: it is a transformation of an original distribution into a more complex distribution by an invertible and differentiable mapping, where the probability density of a sample can be evaluated by transforming it back to the original distribution. The density is evaluated by computing the density of the normalised inverse-transformed sample.&lt;/p&gt;
&lt;p&gt;In practice, this is a bit too general to be of any use. Breaking it down:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The original distribution is simple with well-known statistical properties: i.i.d. Gaussian or uniform distributions.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The transformation function is expected to be complicated, and is normally specified as a series of successive transformations, each simpler (though expressive enough) and easy to parametrise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Each simple transformation is itself invertible and differentiable, therefore guaranteeing that the overall transformation is too.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We want the transformation to be &lt;em&gt;normalised&lt;/em&gt;: the cumulative probability density of the generated targets from latent variables has to be equal 1. Otherwise, flowing backwards to use the properties of the original would make no sense. The word &lt;em&gt;normalising&lt;/em&gt; refers to this operation, and not to the fact that the original distribution &lt;em&gt;could&lt;/em&gt; be normal.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Geometrically, the probability distribution around each point in the latent variables space has a certain volume that is successively transformed with each transformation. Keeping track of all the volume changes ensures that we can relate probability density functions in the original space and the target space.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How to keep track? This is where the condition of having invertible and differentiable transformation becomes important. (Math-speak: we have a series of diffeomorphisms which are transformations from one infinitesimal volume to another. They are invertible and differentiable, and their inverses are also differentiable.) If one imagines a small volume of space around a starting point, that volume gets distorted along the way. At each point, the transformation is differentiable and can be approximated by a linear transformation (a matrix). That matrix is the Jacobian of the transformation at that point (diffeomorphims also means that the Jacobian matrix exists and is invertible). Being invertible, the matrix has no zero eigenvalues and the change of volume is locally equal to the product of all the eigenvalues: the volume gets squeezed along some dimensions, expanded along others, rotations are irrelevant. The product of the eigenvalues is the determinant of the matrix. A negative eigenvalue would mean that the infinitesimal volume is ‘flipped’ along that direction. That sign is irrelevant: the local volume change is therefore the absolute value of the determinant.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We can already anticipate a calculation nightmare: determinants are computationally very heavy. Additionally, in order to backpropagate a loss to optimise the transformations’ parameters, we will need the Jacobians of the inverse transformations (the inverse of the transformmation Jacobian). Without further simplifying assumptions or tricks, normalising flows would be impractical for large dimensions.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;some-math&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Some math&lt;/h3&gt;
&lt;p&gt;The starting distribution is a random variable &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; with a support in &lt;span class=&#34;math inline&#34;&gt;\(\mathbb{R}^D\)&lt;/span&gt;. For simplicity, we will assume just assume that the support is &lt;span class=&#34;math inline&#34;&gt;\(\mathbb{R}^D\)&lt;/span&gt; since using measurable supports does not change the results. If &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; is transformed into &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; by an invertible function/mapping &lt;span class=&#34;math inline&#34;&gt;\(f: \mathbb{R}^D \rightarrow \mathbb{R}^D\)&lt;/span&gt; (&lt;span class=&#34;math inline&#34;&gt;\(Y=f(X)\)&lt;/span&gt;), then the density function of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
P_Y(\vec{y}) &amp;amp; = P_X(\vec{x}) \left| \det \nabla f^{-1}(\vec{y})  \right| \\
                &amp;amp; = P_X(\vec{x}) \left| \det\nabla f(\vec{x}) \right|^{-1}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\vec{x} = f^{-1}(\vec{y})\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\nabla\)&lt;/span&gt; represents the Jacobian operator. Note the use of &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}\)&lt;/span&gt; to denote vectors instead of the normal &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}\)&lt;/span&gt; which I find on-screen easy to mistake for a constant.&lt;/p&gt;
&lt;p&gt;Following &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is the &lt;em&gt;generative&lt;/em&gt; direction; following &lt;span class=&#34;math inline&#34;&gt;\(f^{-1}\)&lt;/span&gt; is the &lt;em&gt;normalising&lt;/em&gt; direction (as well as being the &lt;em&gt;inference&lt;/em&gt; direction in a more general context).&lt;/p&gt;
&lt;p&gt;If &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; was a series of individual transformation &lt;span class=&#34;math inline&#34;&gt;\(f = f_1 \circ f_i \circ \cdots \ f_N\)&lt;/span&gt;, then it naturally follows that:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\det\nabla f(\vec{x})      &amp;amp; = \prod_{i=1}^N{\det \nabla f_i(\vec{x}_i)} \\
\det\nabla f^{-1}(\vec{x}) &amp;amp; = \prod_{i=1}^N{\det \nabla f_i^{-1}(\vec{x}_i)}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In order to make clear that the Jacobian is &lt;em&gt;not&lt;/em&gt; taken wrt the starting latent variables &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;, we use the notation:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\vec{x}_i = f_{i-1}(\vec{x}_{i-1})
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;training-loss-optimisation-and-information-flow&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Training loss optimisation and information flow&lt;/h2&gt;
&lt;p&gt;Before moving into examples for normalising flows, we need to comment on the loss function optimisation. How do we determine the generative model’s parameters so that the generated distribution is as close as possible to the real distribution (or at least to the distribution of the samples drawn from that true distribution)?&lt;/p&gt;
&lt;p&gt;A standard way to do this is to calculate the Kullback-Leibler divergence between the two. Recall that the KL divergence &lt;span class=&#34;math inline&#34;&gt;\(\mathbb{KL}(P \vert \vert Q)\)&lt;/span&gt; is &lt;em&gt;not&lt;/em&gt; a distance as it is not symmetric. I personally read &lt;span class=&#34;math inline&#34;&gt;\(\mathbb{KL}(P \vert \vert Q)\)&lt;/span&gt; as “the loss of information on the true &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; if using the approximation &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt;” as a way to keep the two distributions at their right place (writing &lt;span class=&#34;math inline&#34;&gt;\(\mathbb{KL}(P_{true} \vert \vert Q_{est.})\)&lt;/span&gt; helps clarify the proper order).&lt;/p&gt;
&lt;p&gt;The KL divergence is defined as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\mathbb{KL}(P_{true} \vert \vert Q_{est.}) = \mathbb{E}_{P_{true}(\vec{x})} \log \frac{P_{true}(\vec{x})}{Q_{est.}(\vec{x})}
\end{aligned}
\]&lt;/span&gt;
Or for a discrete distribution:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\mathbb{KL}(P_{true} \vert \vert Q_{est}) &amp;amp; =  \sum_{\vec{x} \in X} P_{true}(\vec{x}) \log \frac{P_{true}(\vec{x})}{Q_{est}(\vec{x})} \\
                                          &amp;amp; =  \sum_{\vec{x} \in X} P_{true}(\vec{x}) \left[ \log P_{true}(\vec{x}) - \log Q_{est}(\vec{x}) \right] 
\end{aligned} 
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In our particular case, this becomes:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\mathbb{KL}(P_{true} \vert \vert P_Y) &amp;amp; = \sum_{\vec{x} \in X} {P_{true}(\vec{x}) \log \frac{P_{true}(\vec{x})}{P_Y(\vec{y})}} \\
                                      &amp;amp; = \sum_{\vec{x} \in X} {P_{true}(\vec{x}) \left[ \log P_{true}(\vec{x}) - \log P_Y(\vec{y}) \right] }
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;since:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
P_Y(\vec{y}) &amp;amp; = P_X(\vec{x}) \left| det \nabla f^{-1}(\vec{y})  \right| \\
&amp;amp; = P_X(\vec{x}) \left| det\nabla f(\vec{x}) \right|^{-1}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We end up with:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{split}
\mathbb{KL}(P_{true} \vert \vert P_Y) &amp;amp; = \sum_{\vec{x} \in X} {P_{true}(\vec{x}) \left[ \log P_{true}(\vec{x})  - \log \left( P_X(\vec{x}) \left| det \nabla f(\vec{y})  \right|^{-1} \right) \right] }
\end{split}
\]&lt;/span&gt;
Minimising this divergence is achieved by changing the parameters which generate &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The divergence is one of many measures that can be used to measure the distance (in the loose sense of the word) between the true and generated distributions. But the KL divergence illustrates how logarithms of the probability distributions naturally appear. A common formulation of the loss is the Wasserstein distance. In the setting of the normalising flows (and VAEs), we have two transformations: the inference direction (the encoder) and the generative direction (the decoder). Given the back-and-forth nature, it makes sense to &lt;em&gt;not&lt;/em&gt; favour one direction over the other. Instead of using the KL divergence which is not symmetric, use the mutual information (this is equivalent to using free energy as in &lt;span class=&#34;citation&#34;&gt;(Rezende and Mohamed &lt;a href=&#34;#ref-rezendeVariationalInferenceNormalizing2016&#34; role=&#34;doc-biblioref&#34;&gt;2016&lt;/a&gt;)&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;Regardless of the choice of loss function, it is obvious that optimising &lt;span class=&#34;math inline&#34;&gt;\(\mathbb{KL}(P_{true} \vert \vert P_Y)\)&lt;/span&gt; cannot be contemplated without serious optimisations. Alternatively, finding more tractable alternative distance measurements is an active research topic.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;basic-flows&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Basic flows&lt;/h2&gt;
&lt;p&gt;When normalizing flows were introduced by &lt;span class=&#34;citation&#34;&gt;(Rezende and Mohamed &lt;a href=&#34;#ref-rezendeVariationalInferenceNormalizing2016&#34; role=&#34;doc-biblioref&#34;&gt;2016&lt;/a&gt;)&lt;/span&gt;, they experimented with simple transformations: a linear transformation (with a simple non-linear function) called &lt;em&gt;planar flows&lt;/em&gt; and flows within a space centered on a reference latent variable called &lt;em&gt;radial flows&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;planar-flows&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Planar Flows&lt;/h2&gt;
&lt;p&gt;A planar flow is formulated as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i(\vec{x}_i) = \vec{x}_i + \vec{u_i}  h(\vec{w}_i^\intercal \vec{x}_i + b_i)
\]&lt;/span&gt;
where &lt;span class=&#34;math inline&#34;&gt;\(\vec{u}_i\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\vec{w}_i\)&lt;/span&gt; are vectors, &lt;span class=&#34;math inline&#34;&gt;\(h()\)&lt;/span&gt; is a non-linear real function and &lt;span class=&#34;math inline&#34;&gt;\(b_i\)&lt;/span&gt; is a scalar.&lt;/p&gt;
&lt;p&gt;By defining:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\psi_i(\vec{z}) = h&amp;#39;(\vec{w}^\intercal \vec{z} + b_i) \vec{w}_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;the determinant required to normalize the flow can be simplified to (see original paper for the short steps involved):&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left| \det \frac{\partial f_i}{\partial x_i}  \right| = \left| \det \left( \mathbb{I} + \vec{u_i} \psi_i(\vec{x}_i)^\intercal \right) \right| = \left| 1 + \vec{u_i}^\intercal \psi_i(\vec{x}_i)  \right|
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This is a more tractable expression.&lt;/p&gt;
&lt;div id=&#34;radial-flows&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Radial flows&lt;/h3&gt;
&lt;p&gt;The formulation of the radial flows takes a reference hyper-ball centered at a reference point &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}_0\)&lt;/span&gt;. Any point &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}\)&lt;/span&gt; gets moved in the direction of &lt;span class=&#34;math inline&#34;&gt;\(\vec{x} - \vec{x}_0\)&lt;/span&gt;. That move is dependent on &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}\)&lt;/span&gt;. In other words, imagine a plain hyper-ball, after many such transformations, you obtain a hyper-potato.&lt;/p&gt;
&lt;p&gt;The flows are defined as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i(\vec{x}_i) = \vec{x}_i + \beta_i h(\alpha_i, \rho_i) \left( \vec{x}_i - \vec{x}_0 \right)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\alpha_i\)&lt;/span&gt; is a strictly positive scalar, &lt;span class=&#34;math inline&#34;&gt;\(\beta_i\)&lt;/span&gt; is a scalar, &lt;span class=&#34;math inline&#34;&gt;\(\rho_i = \left|| \vec{x}_i - \vec{x}_0 \right||\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(h(\alpha_i, \rho_i) = \frac{1}{\alpha_i + \rho_i}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;This family of functions gives the following expression of the determinant:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left| \det \nabla f_i(\vec{x}_i) \right| = \left[ 1 + \beta_i h(\alpha_i, \rho_i) \right] ^{D-1} \left[ 1 + \beta_i h(\alpha_i, \rho_i) +  \beta_i \rho_i h&amp;#39;(\alpha_i, \rho_i) \right]
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Again, this is a more tractable expression.&lt;/p&gt;
&lt;p&gt;Unfortunately, it was found that those transformations do not scale well to high-dimensional latent space.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;more-complex-flows&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;More complex flows&lt;/h2&gt;
&lt;div id=&#34;residual-flows-discrete-flows&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Residual flows (discrete flows)&lt;/h3&gt;
&lt;p&gt;Various proposals were initially put forward with common aims: replacing &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; by a series of sequentially composed simpler but expressive base functions and paying particular attention the computational costs. (refer &lt;span class=&#34;citation&#34;&gt;(Kobyzev, Prince, and Brubaker &lt;a href=&#34;#ref-kobyzevNormalizingFlowsIntroduction2020a&#34; role=&#34;doc-biblioref&#34;&gt;2020&lt;/a&gt;)&lt;/span&gt; and &lt;span class=&#34;citation&#34;&gt;(Papamakarios et al. &lt;a href=&#34;#ref-papamakariosNormalizingFlowsProbabilistic2019&#34; role=&#34;doc-biblioref&#34;&gt;2019&lt;/a&gt;)&lt;/span&gt; for details).&lt;/p&gt;
&lt;p&gt;Residual flows &lt;span class=&#34;citation&#34;&gt;(He et al. &lt;a href=&#34;#ref-heDeepResidualLearning2015&#34; role=&#34;doc-biblioref&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt; were a key development. As the name suggests, the transformations mirror the neural networks RevNet structure. Explicitly, &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is defined as &lt;span class=&#34;math inline&#34;&gt;\(f(x) = x + \phi(x)\)&lt;/span&gt;. The left-hand side identity term is a matrix where all the eigenvalues are 1 (duh). If &lt;span class=&#34;math inline&#34;&gt;\(\phi(x)\)&lt;/span&gt; represented a simple matrix multiplication, imposing the condition that all its eigenvalues of the righthand side term are strictly strictly between 0 and 1 ensure that &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; remains invertible. An equivalent, and more general condition, is to impose that &lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt; is Lipschitz-continuous with a constant below 1. That is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\forall x, y \qquad  0 &amp;lt; \left| \phi(x) - \phi(y) \right| &amp;lt; \left| x - y \right|
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and therefore:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\forall x, h&amp;gt;0 \qquad  0 &amp;lt; \frac{\left| \phi(x+h) - \phi(x) \right|}{h} &amp;lt; 1
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Thanks to this condition, not only &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is invertible, but all the eigenvalues of &lt;span class=&#34;math inline&#34;&gt;\(\nabla f = \mathbb{I} + \nabla \phi(x)\)&lt;/span&gt; are strictly positive (adding a transformation with unity eigenvalues (i.e. &lt;span class=&#34;math inline&#34;&gt;\(\mathbb{I}\)&lt;/span&gt;) and a transformation with eigenvalues strictly below unity (in norm) cannot result in a transformation with nil eigenvalues). Therefore, we can be certain that $f = ( + (x)) = ( + (x)) $ (no negative eigenvalues).&lt;/p&gt;
&lt;p&gt;Recalling that &lt;span class=&#34;math inline&#34;&gt;\(det(e^A) = e^{tr(A)}\)&lt;/span&gt; and the Taylor expansion of &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;, we obtain the following simplification:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\log \enspace \vert \det \nabla f \vert &amp;amp; = \log \enspace \det(\mathbb{I} + \nabla \phi) \\ 
                                       &amp;amp; = tr(\log (\mathbb{I} + \nabla \phi)) \\
\log \enspace \vert \det \nabla f \vert &amp;amp; = \sum_{k=1}^{\infty}{(-1)^{k+1} \frac{tr(\nabla \phi)^k}{k}}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Obviously a trace is much easier to calculate than a determinant. However, the expression now becomes an infinite series. One of the core result of the cited paper is an algorithm to limit the number of terms to calculate in this infinite series.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;other-versions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Other versions&lt;/h2&gt;
&lt;p&gt;Table from Papamakorios&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;continuous-flows&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Continuous flows&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;neural-ordinary-differential-equations&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Neural ordinary differential equations&lt;/h1&gt;
&lt;p&gt;One of the Best Papers of NeurIPS 2018&lt;/p&gt;
&lt;div id=&#34;continuous-flows-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Continuous flows&lt;/h2&gt;
&lt;div id=&#34;continuous-flows-means-no-crossover&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Continuous flows means no-crossover&lt;/h3&gt;
&lt;p&gt;Not the case for residual which have discrete steps.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;universal-ordinary-differential-equations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Universal ordinary differential equations&lt;/h2&gt;
&lt;/div&gt;
&lt;div id=&#34;stochastic-differential-equations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Stochastic differential equations&lt;/h2&gt;
&lt;/div&gt;
&lt;div id=&#34;other&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Other&lt;/h2&gt;
&lt;p&gt;Previously mentioned generative models can be improved with normalising flows&lt;/p&gt;
&lt;p&gt;Flow-GAN Grover, Dhan Ermon, Flow-GAN combining Mx Likelihood and adversarial learning and generative model&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;optimisation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Optimisation&lt;/h2&gt;
&lt;p&gt;Divergence / distance measures&lt;/p&gt;
&lt;p&gt;Kullback-Leibner / Jensen-Shannon divergence / Wasserstein distance&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references hanging-indent&#34;&gt;
&lt;div id=&#34;ref-FastLearningAlgorithm2006&#34;&gt;
&lt;p&gt;“A Fast Learning Algorithm for Deep Belief Nets.” 2006. &lt;em&gt;MIT Press Journals&lt;/em&gt;, Neural Computation,, May. &lt;a href=&#34;https://www.mitpressjournals.org/doi/10.1162/neco.2006.18.7.1527&#34;&gt;https://www.mitpressjournals.org/doi/10.1162/neco.2006.18.7.1527&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-chenNeuralOrdinaryDifferential2019&#34;&gt;
&lt;p&gt;Chen, Ricky T. Q., Yulia Rubanova, Jesse Bettencourt, and David Duvenaud. 2019. “Neural Ordinary Differential Equations,” December. &lt;a href=&#34;http://arxiv.org/abs/1806.07366&#34;&gt;http://arxiv.org/abs/1806.07366&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-dinhNICENonlinearIndependent2015&#34;&gt;
&lt;p&gt;Dinh, Laurent, David Krueger, and Yoshua Bengio. 2015. “NICE: Non-Linear Independent Components Estimation,” April. &lt;a href=&#34;http://arxiv.org/abs/1410.8516&#34;&gt;http://arxiv.org/abs/1410.8516&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-GoodfellowDeepLearning2016&#34;&gt;
&lt;p&gt;Goodfellow, Ian, Yoshua Bengio, and Aaron Courville. 2016. &lt;em&gt;Deep Learning&lt;/em&gt;. MIT Press.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-heDeepResidualLearning2015&#34;&gt;
&lt;p&gt;He, Kaiming, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. 2015. “Deep Residual Learning for Image Recognition,” December. &lt;a href=&#34;http://arxiv.org/abs/1512.03385&#34;&gt;http://arxiv.org/abs/1512.03385&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-kingmaIntroductionVariationalAutoencoders2019&#34;&gt;
&lt;p&gt;Kingma, Diederik P., and Max Welling. 2019. “An Introduction to Variational Autoencoders.” &lt;em&gt;Foundations and Trends in Machine Learning&lt;/em&gt; 12 (4): 307–92. &lt;a href=&#34;https://doi.org/10/ggfm34&#34;&gt;https://doi.org/10/ggfm34&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-kobyzevNormalizingFlowsIntroduction2020a&#34;&gt;
&lt;p&gt;Kobyzev, Ivan, Simon J. D. Prince, and Marcus A. Brubaker. 2020. “Normalizing Flows: An Introduction and Review of Current Methods.” &lt;em&gt;IEEE Transactions on Pattern Analysis and Machine Intelligence&lt;/em&gt;, 1–1. &lt;a href=&#34;https://doi.org/10.1109/TPAMI.2020.2992934&#34;&gt;https://doi.org/10.1109/TPAMI.2020.2992934&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-lucasUnderstandingPosteriorCollapse2019&#34;&gt;
&lt;p&gt;Lucas, James, George Tucker, Roger Grosse, and Mohammad Norouzi. 2019a. “Understanding Posterior Collapse in Generative Latent Variable Models | Semantic Scholar.” In &lt;em&gt;DeepGenStruct Worshop&lt;/em&gt;. &lt;a href=&#34;https://www.semanticscholar.org/paper/Understanding-Posterior-Collapse-in-Generative-Lucas-Tucker/7e2f5af5d44890c08ef72a5070340e0ffd3643ea&#34;&gt;https://www.semanticscholar.org/paper/Understanding-Posterior-Collapse-in-Generative-Lucas-Tucker/7e2f5af5d44890c08ef72a5070340e0ffd3643ea&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-lucasDonBlameELBO2019&#34;&gt;
&lt;p&gt;———. 2019b. “Don’t Blame the ELBO! A Linear VAE Perspective on Posterior Collapse,” November. &lt;a href=&#34;http://arxiv.org/abs/1911.02469&#34;&gt;http://arxiv.org/abs/1911.02469&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-papamakariosNormalizingFlowsProbabilistic2019&#34;&gt;
&lt;p&gt;Papamakarios, George, Eric Nalisnick, Danilo Jimenez Rezende, Shakir Mohamed, and Balaji Lakshminarayanan. 2019. “Normalizing Flows for Probabilistic Modeling and Inference,” December. &lt;a href=&#34;http://arxiv.org/abs/1912.02762&#34;&gt;http://arxiv.org/abs/1912.02762&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-rezendeVariationalInferenceNormalizing2016&#34;&gt;
&lt;p&gt;Rezende, Danilo Jimenez, and Shakir Mohamed. 2016. “Variational Inference with Normalizing Flows,” June. &lt;a href=&#34;http://arxiv.org/abs/1505.05770&#34;&gt;http://arxiv.org/abs/1505.05770&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-russellArtificialIntelligenceModern2020&#34;&gt;
&lt;p&gt;Russell, Stuart, and Peter Norvig. 2020. &lt;em&gt;Artificial Intelligence: A Modern Approach&lt;/em&gt;. 4th ed. Pearson Series on Artificial Intelligence. Pearson. &lt;a href=&#34;http://aima.cs.berkeley.edu/&#34;&gt;http://aima.cs.berkeley.edu/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-theodoridisMachineLearningBayesian2020&#34;&gt;
&lt;p&gt;Theodoridis, Sergios. 2020. &lt;em&gt;Machine Learning: A Bayesian and Optimization Perspective&lt;/em&gt;. Amsterdam Boston Heidelberg London New York Oxford Paris San Diego San Francisco Singapore Sydney Tokyo: Elsevier, AP. &lt;a href=&#34;https://doi.org/10.1016/C2019-0-03772-7&#34;&gt;https://doi.org/10.1016/C2019-0-03772-7&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;appendix-appendix&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Appendix&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;more-information&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;More information&lt;/h1&gt;
&lt;p&gt;This will be Appendix A.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;one-more-thing&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;One more thing&lt;/h1&gt;
&lt;p&gt;This will be Appendix B.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Piece of trivia: It seems that this is pronounced Counta-tch instead of counta-sh.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;Incidentally, this observation is made in the last sentence of the last paragraph of the last chapter of the &lt;a href=&#34;https://www.deeplearningbook.org/&#34;&gt;Deep Learning Book&lt;/a&gt; &lt;span class=&#34;citation&#34;&gt;(Goodfellow, Bengio, and Courville &lt;a href=&#34;#ref-GoodfellowDeepLearning2016&#34; role=&#34;doc-biblioref&#34;&gt;2016&lt;/a&gt;)&lt;/span&gt; &lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Change of template</title>
      <link>/2020/08/12/miscellaneous.html</link>
      <pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate>
      <guid>/2020/08/12/miscellaneous.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;I moved to a richer &lt;a href=&#34;https://sourcethemes.com/academic/&#34;&gt;Hugo template&lt;/a&gt;, partly to move things around under the hood, but importantly it gives a sounder platform for the future.&lt;/p&gt;
&lt;p&gt;However, it took many hours of frustration to get &lt;code&gt;blogdown&lt;/code&gt; and the template to nicely render &lt;span class=&#34;math inline&#34;&gt;\(\LaTeX\)&lt;/span&gt; formulas. In the end, it was very simple, although no documentation or blog posts helped: the &lt;code&gt;mathjax: true&lt;/code&gt; YAML header option needs to be changed to &lt;code&gt;math: true&lt;/code&gt;. No need to alternate between &lt;code&gt;.Rmd&lt;/code&gt; or &lt;code&gt;.md&lt;/code&gt; or &lt;code&gt;.Rmarkdown&lt;/code&gt; files, mess around with &lt;code&gt;config.toml&lt;/code&gt; or &lt;code&gt;params.toml&lt;/code&gt;, chase down unknown &lt;code&gt;pandoc&lt;/code&gt; binaries or add new &lt;code&gt;partials&lt;/code&gt; snippets.&lt;/p&gt;
&lt;p&gt;In addition, I finally figured out how to automatically generate table of contents. Insert the following snippet in the file header:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;output:
  blogdown::html_page:
    toc: true&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Presentation at the Kong Kong Machine Learning meetup</title>
      <link>/2020/04/30/presentation-at-the-hong-kong-machine-learning-meetup.html</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      <guid>/2020/04/30/presentation-at-the-hong-kong-machine-learning-meetup.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;I recently made a presentation at the regular &lt;a href=&#34;https://www.meetup.com/Hong-Kong-Machine-Learning-Meetup&#34;&gt;Hong Kong Machine Learning meetup&lt;/a&gt; organised by &lt;a href=&#34;https://gmarti.gitlab.io/&#34;&gt;Gautier Marti&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The presentation was an introduction to &lt;a href=&#34;https://julialang.org/&#34;&gt;Julia&lt;/a&gt; and used as an example a &lt;a href=&#34;https://github.com/Emmanuel-R8/COVID-19-Julia&#34;&gt;SEIR model COVID-19&lt;/a&gt; I had written. The presentation is available on &lt;a href=&#34;https://github.com/Emmanuel-R8/Presentation_HKML_2020_04/raw/master/HKML_Julia_Xarrigan_2020_04_29.pdf&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It seems to have had some &lt;a href=&#34;https://www.linkedin.com/posts/hong-kong-machine-learning_bye-bye-python-hello-julia-activity-6663079161676075009-rWik&#34;&gt;effect&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Forecasting the progression of COVID-19</title>
      <link>/2020/03/25/2020-03-25-forecasting-covid-19.html</link>
      <pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/2020/03/25/2020-03-25-forecasting-covid-19.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#the-neherlab-covid-19-forecast-model&#34;&gt;The &lt;span&gt;Neherlab COVID-19&lt;/span&gt; forecast model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#basic-assumptions&#34;&gt;Basic assumptions&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#age-cohorts&#34;&gt;Age cohorts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#severity&#34;&gt;Severity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#seasonality&#34;&gt;Seasonality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#transmission-reduction&#34;&gt;Transmission reduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#details-of-the-model&#34;&gt;Details of the model&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#population-compartments&#34;&gt;Population compartments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#model-parameters&#34;&gt;Model parameters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#infection&#34;&gt;Infection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#after-infection&#34;&gt;After infection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#load-data&#34;&gt;Load data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#initialise-parameters&#34;&gt;Initialise parameters&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#fixed-constants&#34;&gt;Fixed constants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#infrastructure&#34;&gt;Infrastructure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#parameter-vector&#34;&gt;Parameter vector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#population&#34;&gt;Population&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#parameters-vector&#34;&gt;Parameters vector&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#differential-equation-solver&#34;&gt;Differential equation solver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bilibliography&#34;&gt;Bilibliography&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;the-neherlab-covid-19-forecast-model&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The &lt;a href=&#34;https://neherlab.org/covid19/&#34;&gt;Neherlab COVID-19&lt;/a&gt; forecast model&lt;/h1&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using CSV, Dates;
using DataFrames, DataFramesMeta;
using Plots, PyPlot;
using DifferentialEquations;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is more a data science post than machine learning. It was born after reading a &lt;a href=&#34;https://www.imperial.ac.uk/media/imperial-college/medicine/sph/ide/gida-fellowships/Imperial-College-COVID19-NPI-modelling-16-03-2020.pdf&#34;&gt;report&lt;/a&gt; from Imperial College London and finding a forecasting model by &lt;a href=&#34;https://neherlab.org/covid19/&#34;&gt;NeherLab&lt;/a&gt;. The numbers produced by those models can only be described as terrifying.&lt;/p&gt;
&lt;p&gt;How do those models work? How are they calibrated?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BUT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Remember that whatever concerns one can have about their precision, those models are all absolutely clear that social-distancing, quarantining have a massive impact on death rates. Being careful saves lives. If anybody feels like ignoring those precautions out of excess testosterone, they are at risk of killing others.&lt;/p&gt;
&lt;p&gt;This post started from one of the pages of the NeherLab site describing their methodology. The work that team is achieving deserves more credit than I can give them.&lt;/p&gt;
&lt;p&gt;The NeherLab website, including the model, is entirely written in Javascript. This is difficul to understand and audit.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;basic-assumptions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic assumptions&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: This is not an introduction to SEIR (and variant) compartment modelling of epidemies. For an introduction (difficult to avoid the maths), see a presentation by the &lt;a href=&#34;http://indico.ictp.it/event/7960/session/3/contribution/19/material/slides/0.pdf&#34;&gt;Swiss Tropical and Public Health Institute&lt;/a&gt;. &lt;a href=&#34;https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology&#34;&gt;Wikipedia&lt;/a&gt; is always an option.&lt;/p&gt;
&lt;div id=&#34;overview&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Overview&lt;/h3&gt;
&lt;p&gt;The model works as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;susceptible individuals are exposed/infected through contact with infectious individuals. Each infectious individual causes on average &lt;span class=&#34;math inline&#34;&gt;\(R_0\)&lt;/span&gt; secondary infections while they are infectious.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Transmissibility of the virus could have seasonal variation which is parameterized with the parameter “seasonal forcing” (amplitude) and “peak month” (month of most efficient transmission).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;exposed individuals progress to a symptomatic/infectious state after an average latency&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;infectious individuals recover or progress to severe disease. The ratio of recovery to severe progression depends on age&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;severely sick individuals either recover or deteriorate and turn critical. Again, this depends on the age&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;critically ill individuals either return to regular hospital or die. Again, this depends on the age&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The individual parameters of the model can be changed to allow exploration of different scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;age-cohorts&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Age cohorts&lt;/h3&gt;
&lt;p&gt;COVID-19 is much more severe in the elderly and proportion of elderly in a community is therefore an important determinant of the overall burden on the health care system and the death toll. We collected age distributions for many countries from data provided by the UN and make those available as input parameters. Furthermore, we use data provided by the epidemiology group by the &lt;a href=&#34;http://weekly.chinacdc.cn/en/article/id/e53946e2-c6c4-41e9-9a9b-fea8db1a8f51&#34;&gt;Chinese CDC&lt;/a&gt; to estimate the fraction of severe and fatal cases by age group.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;severity&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Severity&lt;/h3&gt;
&lt;p&gt;The basic model deals with 3 levels of severity: slow, moderate and fast transmissions.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# severityLevel = :slow;
severityLevel = :moderate;
# severityLevel = :fast;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;seasonality&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Seasonality&lt;/h2&gt;
&lt;p&gt;Many respiratory viruses such as influenza, common cold viruses (including other coronaviruses) have a pronounced seasonal variation in incidence which is in part driven by climate variation through the year. We model this seasonal variation using a sinusoidal function with an annual period. This is a simplistic way to capture seasonality. Furthermore, we don’t know yet how seasonality will affect COVID-19 transmission.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Northern or southern hemisphere
latitude = :north;
# latitude = :tropical;
# latitude = :south;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# The time unit is days (as floating point)
# Day 0 is taken at 1 March 2020
BASE_DATE = Date(2020, 3, 1);
BASE_DAYS = 0;

function date2days(d) 
    return convert(Float64, datetime2rata(d) - datetime2rata(BASE_DATE))
end;

function days2date(d) 
    return BASE_DATE + Day(d)
end;    &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Default values for R_0
baseR₀ = Dict( (:north,    :slow)     =&amp;gt; 2.2, 
               (:north,    :moderate) =&amp;gt; 2.7, 
               (:north,    :fast)     =&amp;gt; 3.2, 
               (:tropical, :slow)     =&amp;gt; 2.0, 
               (:tropical, :moderate) =&amp;gt; 2.5, 
               (:tropical, :fast)     =&amp;gt; 3.0,
               (:south,    :slow)     =&amp;gt; 2.2, 
               (:south,    :moderate) =&amp;gt; 2.7, 
               (:south,    :fast)     =&amp;gt; 3.2);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Peak date
peakDate = Dict( :north     =&amp;gt; date2days(Date(2020, 1, 1)), 
                 :tropical  =&amp;gt; date2days(Date(2020, 1, 1)),    # although no impact
                 :south     =&amp;gt; date2days(Date(2020, 7, 1)));&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Seasonal forcing parameter \epsilon
ϵ = Dict( (:north,    :slow)     =&amp;gt; 0.2, 
          (:north,    :moderate) =&amp;gt; 0.2, 
          (:north,    :fast)     =&amp;gt; 0.1, 
          (:tropical, :slow)     =&amp;gt; 0.0, 
          (:tropical, :moderate) =&amp;gt; 0.0, 
          (:tropical, :fast)     =&amp;gt; 0.0,
          (:south,    :slow)     =&amp;gt; 0.2, 
          (:south,    :moderate) =&amp;gt; 0.2, 
          (:south,    :fast)     =&amp;gt; 0.1);&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Gives R_0 at a given date
function R₀(d; r_0 = missing, latitude = :north, severity = :moderate)
    if ismissing(r_0)
        r₀ = baseR₀[(latitude, severity)]
    else
        r₀ = r_0
    end
    eps = ϵ[(latitude, severity)]
    peak = peakDate[latitude]
    
    return r₀ * (1 + eps * cos(2.0 * π * (d - peak) / 365.25))
end;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;transmission-reduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Transmission reduction&lt;/h2&gt;
&lt;p&gt;The tool allows one to explore temporal variation in the reduction of transmission by infection
control measures. This is implemented as a curve through time that can be dragged by the mouse to
modify the assumed transmission. The curve is read out and used to change the transmission relative
to the base line parameters for &lt;span class=&#34;math inline&#34;&gt;\(R_0\)&lt;/span&gt; and seasonality. Several studies attempt to estimate the
effect of different aspects of social distancing and infection control on the rate of transmission.
A report by &lt;a href=&#34;https://www.medrxiv.org/content/10.1101/2020.03.03.20030593v1&#34;&gt;Wang et al&lt;/a&gt; estimates a
step-wise reduction of &lt;span class=&#34;math inline&#34;&gt;\(R_0\)&lt;/span&gt; from above three to around 1 and then to around 0.3 due to successive
measures implemented in Wuhan. &lt;a href=&#34;https://www.pnas.org/content/116/27/13174&#34;&gt;This study&lt;/a&gt; investigates
the effect of school closures on influenza transmission.&lt;/p&gt;
&lt;p&gt;This curve is presented as a list of tuples: (days from start date, ratio). The month starts from the start date. Between dates, the ration is interpolated linearly. After the last date, the ration remains constant.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;startDate = date2days(Date(2020, 3, 1));

mitigationRatio = [(0, 1.00), (30, 0.80), (60, 0.20), (150, 0.50)];

function getCurrentRatio(d; start = BASE_DAYS, schedule = mitigationRatio)
    l = length(schedule)
    
    # If l = 1, ratio will be the only one
    if l == 1 
        return schedule[1][2]
    else
        for i in 2:l
            d1 = schedule[i-1][1]
            d2 = schedule[i  ][1]
            
            if d &amp;lt; d2 
                deltaR = schedule[i][2] - schedule[i-1][2]
                return schedule[i-1][2] + deltaR * (d - d1) / (d2 - d1)
            end
        end
    
        # Last possible choice
        return schedule[l][2]
    end
end;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;details-of-the-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Details of the model&lt;/h2&gt;
&lt;p&gt;Age strongly influences an individual’s response to the virus. The general population is sub-divided in to age classes, indexed by &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;, to allow for variable transition rates dependent upon age.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# The population will be modeled as a single vector. 
# The vector will be a stack of several vectors, each of them represents a compartment.
# Each compartment vector has a size $nAgeGroup$ representing each age group.
# The compartments are: S, E, I, H, C, R, D, K, L

# We also track the hospital bed usage BED and ICU

# Population to compartments
function Pop2Comp(P)
    
    # To make copy/paste less prone to error 
    g = 0
    
    S = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    E = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    I = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    J = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    H = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    C = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    R = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    D = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    K = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    L = P[ g*nAgeGroup + 1: (g+1)*nAgeGroup]; g += 1
    
    BED = P[ g*nAgeGroup + 1: g*nAgeGroup + 1]
    ICU = P[ g*nAgeGroup + 2: g*nAgeGroup + 2]
    
    return S, E, I, J, H, C, R, D, K, L, BED, ICU
end;&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;population-compartments&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Population compartments&lt;/h3&gt;
&lt;p&gt;Qualitatively, the epidemy model dynamics tracks several sub-groups (compartments):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/media/post/2020-COVID/images/States.svg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Susceptible individuals (&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;) are healthy and susceptible to being exposed to the virus by contact with an infected individual.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Exposed individuals (&lt;span class=&#34;math inline&#34;&gt;\(E\)&lt;/span&gt;) are infected but asymptomatic. They progress towards a symptomatic state on average time &lt;span class=&#34;math inline&#34;&gt;\(t_l\)&lt;/span&gt;. Reports are that asymptomatic individuals are contagious. We will assume that they are proportionally less contagious than symptomatic individuals as a percentage &lt;span class=&#34;math inline&#34;&gt;\(\gamma_E\)&lt;/span&gt; of &lt;span class=&#34;math inline&#34;&gt;\(R_0\)&lt;/span&gt;. For the purposes of modelling we will assume (without supporting evidence, but will be the object of parameter estimation):&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;γₑ = 0.50;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Infected individuals (&lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt;) infect an average of &lt;span class=&#34;math inline&#34;&gt;\(R_0\)&lt;/span&gt; secondary infections. On a time-scale of &lt;span class=&#34;math inline&#34;&gt;\(t_i\)&lt;/span&gt;, infected individuals either recover or progress towards severe infection.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From here on, the compartments differ from the NeherLab model is that we split compartments depending on the severity of the symptoms (Severe or Critical) and the location of the individual (out of the hospital infrastructure, isolated in hospital, or isolated in intensive care units). The transitions reflect the following assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Transition between locations is purely a function of bed availability: as soon as beds are available, they are filled by all age groups in their respective proportions.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Transition from severe to critical is assumed to be independent from the location of the patient. For severe patients, the relevance of the location is whether they are isolated or not, that is the possibility to infect susceptible individual. The same way an asymptomatic individual’s attracts a ratio &lt;span class=&#34;math inline&#34;&gt;\(\gamma_e\)&lt;/span&gt;, the other compartments will. The transition from &lt;span class=&#34;math inline&#34;&gt;\(J\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(H\)&lt;/span&gt; to recovery or criticality has a time-scale of &lt;span class=&#34;math inline&#34;&gt;\(t_h\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# R_0 multipliers depending on severity. Subscript matches the compartment&amp;#39;s name.
# Infected / symptomatic individuals
γᵢ=1.0;

# Severe symptoms
γⱼ=1.0;

# Critical symptoms
γₖ = 2.0;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Once critical, the location of a patient influences their chances of recovery. Although we will assume that the time to recovery is identical in all cases, we will assume that the risks will double and triple if a patient is in simple isolation (receiving care but without ICU equipmment) or out of hospital.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Fatality mulitplier.

# In ICU
δᵤ = 1.0;

# In hospital
δₗ = 2.0;

# Out of hospital
δₖ = 3.0;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The time-scale to recovery (&lt;span class=&#34;math inline&#34;&gt;\(R\)&lt;/span&gt;) or death (&lt;span class=&#34;math inline&#34;&gt;\(D\)&lt;/span&gt;) is &lt;span class=&#34;math inline&#34;&gt;\(t_u\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Recovering and recovered individuals [&lt;span class=&#34;math inline&#34;&gt;\(R\)&lt;/span&gt;] can not be infected again. We will assume that recovering individual are not contagious (no medical experience for this assumption for recovering individual).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;model-parameters&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Model parameters&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Many estimates of &lt;span class=&#34;math inline&#34;&gt;\(R_0\)&lt;/span&gt; are in the &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7001239/&#34;&gt;range of 2-3&lt;/a&gt; with some estimates pointing to considerably &lt;a href=&#34;https://www.medrxiv.org/content/10.1101/2020.02.10.20021675v1&#34;&gt;higher values&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The serial interval, that is the time between subsequent infections in a transmission chain, was &lt;a href=&#34;https://www.nejm.org/doi/full/10.1056/NEJMoa2001316&#34;&gt;estimated to be 7-8 days&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The China CDC compiled &lt;a href=&#34;http://weekly.chinacdc.cn/en/article/id/e53946e2-c6c4-41e9-9a9b-fea8db1a8f51&#34;&gt;extensive data on severity and fatality of more than 40 thousand confirmed cases&lt;/a&gt;.
In addition, we assume that a substantial fraction of infections, especially in the young, go unreported. This is encoded in the columns “Confirmed [% of total]”.&lt;/li&gt;
&lt;li&gt;Seasonal variation in transmission is common for many respiratory viruses but the strength of seasonal forcing for COVID19 are uncertain. For more information, see a &lt;a href=&#34;https://smw.ch/article/doi/smw.2020.20224&#34;&gt;study by us&lt;/a&gt; and by &lt;a href=&#34;https://www.medrxiv.org/content/10.1101/2020.03.04.20031112v1&#34;&gt;Kissler et al&lt;/a&gt;.
The parameters of this model fall into three categories: transition time scales, age-specfic parameters and a time-dependent infection rate.&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;transition-time-scales&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Transition time scales&lt;/h4&gt;
&lt;p&gt;The time scales of transition from a compartment to the next: &lt;span class=&#34;math inline&#34;&gt;\(t_l\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(t_i\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(t_h\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(t_c\)&lt;/span&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(t_l\)&lt;/span&gt;: latency time from infection to infectiousness&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(t_i\)&lt;/span&gt;: the time an individual is infectious after which he/she either recovers or falls severely ill&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(t_h\)&lt;/span&gt;: the time a sick person recovers or deteriorates into a critical state&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(t_u\)&lt;/span&gt;: the time a person remains critical before dying or stabilizing (Neherlab uses &lt;span class=&#34;math inline&#34;&gt;\(t_c\)&lt;/span&gt; instead of &lt;span class=&#34;math inline&#34;&gt;\(t_u\)&lt;/span&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Time to infectiousness (written t\_l)
tₗ = Dict(  :slow     =&amp;gt; 5.0, 
            :moderate =&amp;gt; 5.0, 
            :fast     =&amp;gt; 4.0);

# Time to infectiousness (written t\_i)
tᵢ = Dict(  :slow     =&amp;gt; 3.0, 
            :moderate =&amp;gt; 3.0, 
            :fast     =&amp;gt; 3.0);

# Time in hospital bed (not ICU)
tₕ = 4.0;

# Time in ICU 
tᵤ = 14.0;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;age-specfic-parameters&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Age-specfic parameters&lt;/h4&gt;
&lt;p&gt;The age-specific parameters &lt;span class=&#34;math inline&#34;&gt;\(z_a\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(m_a\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(c_a\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(f_a\)&lt;/span&gt; that determine relative rates of different outcomes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(z_a\)&lt;/span&gt;: a set of numbers reflecting to which extent an age group is susceptible to initial contagion. Note that NeherLab denotes this vector by &lt;span class=&#34;math inline&#34;&gt;\(I_a\)&lt;/span&gt; which is confusing with the compartmment evolution &lt;span class=&#34;math inline&#34;&gt;\(I_a(t)\)&lt;/span&gt; notation. (This sort of defeats the purpose of &lt;span class=&#34;math inline&#34;&gt;\(R_0\)&lt;/span&gt;.)&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(m_a\)&lt;/span&gt;: fraction of infectious becoming severe (&lt;strong&gt;Hospitalisation Rate&lt;/strong&gt;) or recovers immediately (&lt;strong&gt;Recovery Rate&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(c_a\)&lt;/span&gt;: fraction of severe cases that turn critical (&lt;strong&gt;Critical Rate&lt;/strong&gt;) or can leave hospital (&lt;strong&gt;Discharge Rate&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_a\)&lt;/span&gt;: fraction of critical cases that are fatal (&lt;strong&gt;Death Rate&lt;/strong&gt;) or recover (&lt;strong&gt;Stabilisation Rate&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;AgeGroup = [&amp;quot;0-9&amp;quot;, &amp;quot;10-19&amp;quot;, &amp;quot;20-29&amp;quot;, &amp;quot;30-39&amp;quot;, &amp;quot;40-49&amp;quot;, &amp;quot;50-59&amp;quot;, &amp;quot;60-69&amp;quot;, &amp;quot;70-79&amp;quot;, &amp;quot;80+&amp;quot;];
zₐ =       [0.05,   0.05,   0.10,    0.15,    0.20,    0.25,    0.30,    0.40,    0.50];
mₐ =       [0.01,   0.03,   0.03,    0.03,    0.06,    0.10,    0.25,    0.35,    0.50];
cₐ =       [0.05,   0.10,   0.10,    0.15,    0.20,    0.25,    0.35,    0.45,    0.55];
fₐ =       [0.30,   0.30,   0.30,    0.30,    0.30,    0.40,    0.40,    0.50,    0.50];

nAgeGroup = length(AgeGroup);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;infrastruture&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Infrastruture&lt;/h4&gt;
&lt;p&gt;The number of beds available is assumed as a fixed resource in time. The number of hospital (resp. ICU) beds in use will be denoted &lt;span class=&#34;math inline&#34;&gt;\(\mathscr{H}(t)\)&lt;/span&gt; (resp. &lt;span class=&#34;math inline&#34;&gt;\(\mathscr{U}(t)\)&lt;/span&gt;) up to a maximum of &lt;span class=&#34;math inline&#34;&gt;\(\mathscr{H}_{max}\)&lt;/span&gt; (resp. &lt;span class=&#34;math inline&#34;&gt;\(\mathscr{U}_{max}\)&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;Although the initial infections took place via dommestic and international travellers (apart from the initial infections in Wuhan obviously), we will assume no net flow of population in and out of a country of interest.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;infection&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Infection&lt;/h3&gt;
&lt;div id=&#34;susceptible&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Susceptible:&lt;/h4&gt;
&lt;p&gt;The &lt;em&gt;base&lt;/em&gt; rate of contagion is denoted as &lt;span class=&#34;math inline&#34;&gt;\(R_0\)&lt;/span&gt;. The actual rate varies with time (to reflect seasons and impact of temperature on virus resilience) and the effectiveness of the mitigation measures such as social distancing. Separately, each age group will have a different sensitivity to infection.&lt;/p&gt;
&lt;p&gt;The infection rate &lt;span class=&#34;math inline&#34;&gt;\(\beta_a(t)\)&lt;/span&gt; is age- and time-dependent. It is given by:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\beta_a(t) = z_a M(t) R_0 \left( 1+\varepsilon \cos \left( 2\pi \frac{t-t_{max}}{t_i} \right) \right) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(z_a\)&lt;/span&gt; is the degree to which particular age groups are sensitive to initial infection. It reflects bioligical sensitivity and to which degree it is isolated from the rest of the population (denoted &lt;span class=&#34;math inline&#34;&gt;\(I_a\)&lt;/span&gt; in NeherLab).&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(M(t)\)&lt;/span&gt; is a time-dependent ratio reflecting the effectiveness of mitigation measures.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon\)&lt;/span&gt; is the amplitude of seasonal variation in transmissibility.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(t_{max}\)&lt;/span&gt; is the time of the year of peak transmission.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Susceptible individuals are exposed to a number of contagious individuals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;asymptomatic infected: &lt;span class=&#34;math display&#34;&gt;\[\gamma_e \beta_a(t) E_a(t)\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;symptomatic infected: &lt;span class=&#34;math display&#34;&gt;\[\gamma_i \beta_a(t) I_a(t)\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;severe not in hospital: &lt;span class=&#34;math display&#34;&gt;\[\gamma_j \beta_a(t) J_a(t)\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;critical not in hospital: &lt;span class=&#34;math display&#34;&gt;\[\gamma_k \beta_a(t) K_a(t)\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The sum of those will be a flow from susceptible (&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;) to (&lt;span class=&#34;math inline&#34;&gt;\(E\)&lt;/span&gt;) exposed individuals.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
S2E_a(t) &amp;amp; = \gamma_e \beta_a(t) E_a(t) + \gamma_i \beta_a(t) I_a(t) + \gamma_j \beta_a(t) K_a(t) + \gamma_k \beta_a(t) L_a(t) \\ 
S2E_a(t) &amp;amp; = \beta_a(t) \left( \gamma_e  E_a(t) + \gamma_i I_a(t) + \gamma_j J_a(t) + \gamma_k K_a(t) \right) \\
E2S_a(t) &amp;amp; = -S2E_a(t) \\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and therefore:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\frac{dS_{a}(t)}{dt} = - S2E_a(t) = E2S_a(t)
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;after-infection&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;After infection&lt;/h3&gt;
&lt;p&gt;Quantitatively, the model expresses how many individuals transfer from one situation/compartment to another. Flows from compartment X to Y are written as &lt;span class=&#34;math inline&#34;&gt;\(X2Y\)&lt;/span&gt; (obviously &lt;span class=&#34;math inline&#34;&gt;\(X2Y = - Y2X\)&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;Note that the compartments are split into age groups.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/media/post/2020-COVID/images/Transitions.svg&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Transitions between compartments&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;epidemiology&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Epidemiology&lt;/h4&gt;
&lt;p&gt;Instead of expressing the sum of the flows at each node, it is easier to express the arrows, and summing them afterwards. For example, arrow from &lt;span class=&#34;math inline&#34;&gt;\(J\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; will be:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[JK_a(t) = \frac{c_a}{t_h} J_a(t)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;with a positive flow following the direction of the arrow.&lt;/p&gt;
&lt;p&gt;In {julia}, this will become:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        JK = cₐ .* J / tₕ&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where &lt;code&gt;J&lt;/code&gt; is a vector representing an age group, &lt;code&gt;.*&lt;/code&gt; is the element-wise multiplication.&lt;/p&gt;
&lt;p&gt;After defining the arrows &lt;span class=&#34;math inline&#34;&gt;\(IJ\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(JK\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(JH\)&lt;/span&gt;, the change in &lt;span class=&#34;math inline&#34;&gt;\(J\)&lt;/span&gt; will simply be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        dJ = IJ - JK - JH&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;bed-transfers&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Bed transfers&lt;/h4&gt;
&lt;p&gt;Individuals are transferred into hospital beds then into ICU beds in the order indicated by the red numbers.&lt;/p&gt;
&lt;p&gt;Critical patients already in hospital go into ICU as spots become available. The freed bed are first made available to critical patients out of hospital (&lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt;). Then, any free beds will receive patients in severe condition.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;safeguards&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Safeguards:&lt;/h4&gt;
&lt;p&gt;Note the need to ensure a few common sense rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;No compartment can have a negative number of people.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The total population figure should remain unchanged. This is done by adjusting the number of susceptible individuals.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Careful accounting of the use of fixed number of hospital beds.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The number of infected people should always be above the number of reported cases.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Helper function to never change the number of individuals in a compartment in a way that would 
# make it below 0.1 (to avoid rounding errors around 0)
function ensurePositive(d,s)
    return max.(d .+ s, 0.1) .- s
end;

    
    
# The dynamics of the epidemy is a function that mutates its argument with a precise signature
# Don&amp;#39;t pay too much attetion to the print debugs/

function epiDynamics!(dP, P, params, t)
    
    S, E, I, J, H, C, R, D, K, L, BED, ICU = Pop2Comp(P)
    
    BED = BED[1]
    ICU = ICU[1]
    
    r₀, tₗ, tᵢ, tₕ, tᵤ, γₑ, γᵢ, γⱼ, γₖ, δₖ, δₗ, δᵤ, startDays = params 
    
    
    ####################################
    # Arrows reflecting epidemiology - Check signs (just in case)
    EI = ones(nAgeGroup) .* E / tₗ;  EI = max.(EI, 0.0); IE = -EI; 
    IJ = mₐ              .* I / tᵢ;  IJ = max.(IJ, 0.0); JI = -IJ
    JK = cₐ              .* J / tₕ;  JK = max.(JK, 0.0); KJ = -JK
    HL = cₐ              .* H / tₕ;  HL = max.(HL, 0.0); LH = -HL
    
    # Recovery arrows
    IR = (1 .- mₐ)       .* I / tᵢ;  IR = max.(IR, 0.0); RI = -IR
    JR = (1 .- cₐ)       .* J / tₕ;  JR = max.(JR, 0.0); RJ = -JR
    HR = (1 .- cₐ)       .* H / tₕ;  HR = max.(HR, 0.0); RH = -HR
    KR = (1 .- δₖ .* fₐ) .* K / tᵤ;  KR = max.(KR, 0.0); RK = -KR
    LR = (1 .- δₗ .* fₐ) .* L / tᵤ;  LR = max.(LR, 0.0); RL = -LR
    CR = (1 .- δᵤ .* fₐ) .* C / tᵤ;  CR = max.(CR, 0.0); RC = -CR
    
    # Deaths
    KD = δₖ .* fₐ        .* K / tᵤ;  KD = max.(KD, 0.0); DK = -KD
    LD = δₗ .* fₐ        .* L / tᵤ;  LD = max.(LD, 0.0); DL = -LD
    CD = δᵤ .* fₐ        .* C / tᵤ;  CD = max.(CD, 0.0); DC = -CD
    
    
    ####################################
    # Bed transfers
    
    ####### Step 1:
    # Decrease in bed usage is (recall that CD and CR are vectors over the age groups) 
    dICU = - (sum(CD) + sum(CR));                 dICU = ensurePositive(dICU, ICU)
    
    # ICU beds available
    ICU_free = ICU_max - (ICU + dICU)
    
    # Move as many patients as possible from $L$ to $C$ in proportion of each group
    ICU_transfer = min(sum(L), ICU_free)
    LC = ICU_transfer / sum(L) .* L;    CL = -LC
    
    # Overall change in ICU bed becomes
    dICU = dICU + ICU_transfer;                   dICU = ensurePositive(dICU, ICU)
    
    # And some normal beds are freed
    dBED = -ICU_transfer;                         dBED = ensurePositive(dBED, BED)
    #print(&amp;quot; dBed step 1 &amp;quot;); println(floor.(sum(dBED)))

    ####### Step 2:
    # Beds available
    BED_free = BED_max - (BED + dBED)
    
    # Move as many patients as possible from $K$ to $L$ in proportion of each group
    BED_transfer = min(sum(K), BED_free)
    KL = BED_transfer / sum(K) .* K;   LK = -KL
    
    # Overall change in normal bed becomes
    dBED = dBED + BED_transfer;                   dBED = ensurePositive(dBED, BED)
    #print(&amp;quot; dBed step 2 &amp;quot;); println(floor.(sum(dBED)))
    

    ####### Step 3:
    # Beds available
    BED_free = BED_max - (BED + dBED)
    
    # Move as many patients as possible from $J$ to $H$ in proportion of each group
    BED_transfer = min(sum(J), BED_free)
    JH = BED_transfer / sum(J) .* J;   HJ = -JH 
    
    # Overall change in ICU bed becomes
    dBED = dBED + BED_transfer;                   dBED = ensurePositive(dBED, BED)
    #print(&amp;quot; dBed step 3 &amp;quot;); println(floor.(sum(dBED)))
    

    ####################################
    # Sum of all flows + Check never negative compartment
    
    # Susceptible    
    # Calculation of β
    β = getCurrentRatio(t; start = BASE_DAYS, schedule = mitigationRatio) .* zₐ .* 
        R₀(t; r_0 = r₀, latitude = Latitude, severity = SeverityLevel)
    
    #print(&amp;quot;r₀&amp;quot;); println(r₀); println(&amp;quot;R₀&amp;quot;); 
    #println(R₀(t; r_0 = r₀, latitude = Latitude, severity = SeverityLevel)); print()
    
    dS = -β .* (γₑ.*E + γᵢ.*I + γⱼ.*J + γₖ.*K);   dS = min.(-0.01, dS); dS = ensurePositive(dS, S)
    
    #print(&amp;quot;dS&amp;quot;); println(floor.(dS)); println(); 
    
    # Exposed
    dE = -dS + IE;                                dE = ensurePositive(dE, E)
    
    # Infected. 
    dI = EI + JI + RI;                            dI = ensurePositive(dI, I)
    
    # Infected no hospital
    dJ = IJ + HJ + KJ + RJ;                       dJ = ensurePositive(dJ, J)
    
    #print(&amp;quot;I &amp;quot;); println(floor.(IJ)); print(&amp;quot;H &amp;quot;); println(floor.(HJ))
    #print(&amp;quot;K &amp;quot;); println(floor.(KJ)); print(&amp;quot;R &amp;quot;); println(floor.(RJ))
    
    # Infected in hospital
    dH = JH + LH + RH ;                           dH = ensurePositive(dH, H)
    
    # Critical no hospital
    dK = JK + LK + DK + RK;                       dK = ensurePositive(dK, K)
    
    # Critical in hospital
    dL = KL + HL + CL + DL + RL;                  dL = ensurePositive(dL, L)
    
    # Critical in ICU
    dC = LC + DC + RC;                            dC = ensurePositive(dC, C)
    
    # Recovery (can only increase)
    dR = IR + JR + HR + KR + LR + CR;             dR = max.(dR, 0.01)
    
    # Dead (can only increase)
    dD = KD + LD + CD;                            dD = max.(dD, 0.01)
    
    # Vector change of population and update in place
    result = vcat(dS, dE, dI, dJ, dH, dC, dR, dD, dK, dL, [dBED], [dICU])
    #print(&amp;quot; dS &amp;quot;); print(floor.(sum(dS))); print(&amp;quot; dE &amp;quot;); print(floor.(sum(dE))); 
    #print(&amp;quot; dI &amp;quot;); print(floor.(sum(dI))); print(&amp;quot; dJ &amp;quot;); println(floor.(sum(dJ))); 
    #print(&amp;quot; dH &amp;quot;); print(floor.(sum(dH))); print(&amp;quot; dC &amp;quot;); print(floor.(sum(dC))); 
    #print(&amp;quot; dR &amp;quot;); print(floor.(sum(dR))); print(&amp;quot; dD &amp;quot;); print(floor.(sum(dD))); 
    #print(&amp;quot; dK &amp;quot;); print(floor.(sum(dK))); print(&amp;quot; dL &amp;quot;); println(floor.(sum(dL))); println(); 
    for i = 1:length(result)
        dP[i] = result[i]
    end

end;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;load-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Load data&lt;/h1&gt;
&lt;p&gt;The data comes from Neherlab’s data repository on &lt;a href=&#34;https://github.com/neherlab/covid19_scenarios_data&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We will use Italy as an example&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;country = &amp;quot;Italy&amp;quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file contains a record of cases day by day.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;cases = DataFrame(CSV.read(&amp;quot;data/World.tsv&amp;quot;, header = 4));
cases = @where(cases, occursin.(country, :location));
sort!(cases, :time);

# Add a time column in the same format as the other dataframes
cases = hcat(DataFrame(t = date2days.(cases[:, :time])), cases);

# Remove any row with no recorded death
cases = cases[cases.deaths .&amp;gt; 0, :];

last(cases[:, [:time, :cases, :deaths]], 6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last rows shows the number of cases and deaths up to the last date in the dataset.&lt;/p&gt;
&lt;p&gt;Plotting the number of death shows an almost exponential increase in numbers (straight line in logarithmic scale).&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using PyPlot;

pyplot();
clf();
ioff();
plot_x = cases.time;
plot_y = cases.deaths;

fig, ax = PyPlot.subplots();

ax.plot(plot_x, plot_y, &amp;quot;ro&amp;quot;);
ax.fill_between(plot_x, plot_y, color=&amp;quot;red&amp;quot;, linewidth=2, label=&amp;quot;Deaths&amp;quot;, alpha=0.3);
ax.legend(loc=&amp;quot;upper left&amp;quot;);
ax.set_xlabel(&amp;quot;time&amp;quot;);
ax.set_ylabel(&amp;quot;Deaths&amp;quot;);
ax.set_yscale(&amp;quot;log&amp;quot;);

PyPlot.savefig(&amp;quot;images/Deaths.png&amp;quot;);&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/media/post/2020-COVID/images/Deaths.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Deaths&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This file contains ICU beds figures.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;ICU_capacity = select(CSV.read(&amp;quot;data/ICU_capacity.tsv&amp;quot;; delim = &amp;quot;\t&amp;quot;), :country, :CriticalCare);
ICU_capacity = @where(ICU_capacity, occursin.(country, :country))[!, :CriticalCare][1];
ICU_capacity = convert(Float64, ICU_capacity);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Country codes are necessary to load the another file.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;country_codes = select(CSV.read(&amp;quot;data/country_codes.csv&amp;quot;), :name, Symbol(&amp;quot;alpha-3&amp;quot;));
country_codes = @where(country_codes, occursin.(country, :name));
countryShort = country_codes[:, Symbol(&amp;quot;alpha-3&amp;quot;)][1];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file contains hospital beds figures.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;hospital_capacity = select(CSV.read(&amp;quot;data/hospital_capacity.csv&amp;quot;, 
                                    types = Dict(:COUNTRY =&amp;gt; String), limit = 1267), :COUNTRY, :YEAR, :VALUE);
hospital_capacity = @where(hospital_capacity, Not(ismissing.(:COUNTRY)));
hospital_capacity = last(@where(hospital_capacity, occursin.(countryShort, :COUNTRY)), 1)[!, :VALUE][1];
hospital_capacity = convert(Float64, hospital_capacity);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file contains a distribution of the population in age groups.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;age_distribution = CSV.read(&amp;quot;data/country_age_distribution.csv&amp;quot;);
age_distribution = @where(age_distribution, occursin.(country, :_key))[!, 2:10];

# Convert to simple matrix
age_distribution = Matrix(age_distribution);
show(age_distribution);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;initialise-parameters&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Initialise parameters&lt;/h1&gt;
&lt;div id=&#34;fixed-constants&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fixed constants&lt;/h2&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;SeverityLevel = :moderate;
Latitude = :north;

StartDate = Date(2020, 3, 1);
StartDays = date2days(StartDate);

EndDate = Date(2020, 9, 1);
EndDays = date2days(EndDate);

tSpan = (StartDays, EndDays);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;infrastructure&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Infrastructure&lt;/h2&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;BED_max = hospital_capacity&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;ICU_max = ICU_capacity&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;parameter-vector&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Parameter vector&lt;/h2&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# r₀, tₗ, tᵢ, tₕ, tᵤ, γᵢ, γⱼ, γₖ, δₖ, δₗ, δᵤ, startDate = params 

parameters = [  baseR₀[Latitude, SeverityLevel], 
                tₗ[SeverityLevel], tᵢ[SeverityLevel], tₕ, tᵤ, 
                γₑ, γᵢ, γⱼ, γₖ, 
                δₖ, δₗ, δᵤ, 
                StartDays];&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;population&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Population&lt;/h2&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;Age_Pyramid = transpose(age_distribution);
Age_Pyramid_frac = Age_Pyramid / sum(Age_Pyramid);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We do not know the number of actual number of infections cases at the start of the model. We only know confirmed cases (almost certainly far below the number of actual infections).&lt;/p&gt;
&lt;p&gt;We assume that actual infections are 3 time more numerous.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;DeathsAtStart = @where(cases, :time .== StartDate)[!, :deaths][1];
ConfirmedAtStart = @where(cases, :time .== StartDate)[!, :cases][1];
EstimatedAtStart = 3.0 * ConfirmedAtStart;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;parameters-vector&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Parameters vector&lt;/h2&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Note that values are inintialised at 1 to avoid division by zero

S0 = Age_Pyramid;
E0 = ones(nAgeGroup);
I0 = EstimatedAtStart * Age_Pyramid_frac;
J0 = ones(nAgeGroup);
H0 = ones(nAgeGroup);
C0 = ones(nAgeGroup);
R0 = ones(nAgeGroup);
D0 = DeathsAtStart * Age_Pyramid_frac;
K0 = ones(nAgeGroup);
L0 = ones(nAgeGroup);

# Everybody confirmed is in hospital
BED = [ConfirmedAtStart];
ICU = [1.0];

P0 = vcat(S0, E0, I0, J0, H0, C0, R0, D0, K0, L0, BED, ICU);
dP = 0 * P0;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;differential-equation-solver&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Differential equation solver&lt;/h1&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;model = ODEProblem(epiDynamics!, P0, tSpan, parameters);&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Note: progress steps might be too quick to see!
sol = solve(model, Tsit5(); progress = false, progress_steps = 5);&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# The solutions are returned as an Array of Arrays: 
#  - it is a vector of size the number of timesteps
#  - each element of the vector is a vector of all the variables
nSteps = length(sol.t);
nVars  = length(sol.u[1]);

# Empty dataframe to contain all the numbers
# (When running a loop at top-level, the global keywrod is necessary to modify global variables.)
solDF = zeros((nSteps, nVars));
for i = 1:nSteps
    global solDF
    solDF[i, :] = sol.u[i]
end;

solDF = hcat(DataFrame(t = sol.t), DataFrame(solDF));

# Let&amp;#39;s clean the names
compartments =  [&amp;quot;S&amp;quot;, &amp;quot;E&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;J&amp;quot;, &amp;quot;H&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;R&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;K&amp;quot;, &amp;quot;L&amp;quot;];
solnames = vcat([:t], [Symbol(c * repr(n)) for c in compartments for n in 0:(nAgeGroup-1)], [:Beds], [:ICU]);
rename!(solDF, solnames);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;# Create sums for each compartment
# (Consider solDF[!, r&amp;quot;S&amp;quot;])
# 
for c in compartments
    col =  [Symbol(c * repr(n)) for n in 0:(nAgeGroup-1)]
    s = DataFrame(C = sum.(eachrow(solDF[:, col])))
    rename!(s, [Symbol(c)])
        
    global solDF = hcat(solDF, s)
end;

# The D column gives the final number of dead.
println(last(solDF[:, Symbol.(compartments)], 5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last row shows the final sizes of the various compartments.&lt;/p&gt;
&lt;p&gt;Next is the evolution of the over time.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;pyplot();
clf();
ioff();

fig, ax = PyPlot.subplots();

ax.plot(solDF.t, solDF.D, label = &amp;quot;Forecast&amp;quot;);
ax.plot(solDF.t, solDF.R, label = &amp;quot;Recoveries&amp;quot;);
ax.plot(cases.t, cases.deaths, &amp;quot;ro&amp;quot;, label = &amp;quot;Actual&amp;quot;, alpha = 0.3);

ax.legend(loc=&amp;quot;lower right&amp;quot;);
ax.set_xlabel(&amp;quot;time&amp;quot;);
ax.set_ylabel(&amp;quot;Individuals&amp;quot;);
ax.set_yscale(&amp;quot;log&amp;quot;);

PyPlot.savefig(&amp;quot;images/DeathsForecast.png&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/media/post/2020-COVID/images/DeathsForecast.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Increase in Recoveries and Deaths over time&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;It is clear the model forecasts a faster growth than reality. A parameter estimation is necessary.&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;pyplot();
clf();
ioff();

fig, ax = PyPlot.subplots();

ax.plot(solDF.t, solDF.Beds, label = &amp;quot;Beds&amp;quot;);
ax.plot(solDF.t, solDF.ICU, label = &amp;quot;ICU&amp;quot;);

ax.legend(loc=&amp;quot;lower right&amp;quot;);
ax.set_xlabel(&amp;quot;time&amp;quot;);
ax.set_ylabel(&amp;quot;Number of beds&amp;quot;);
ax.set_yscale(&amp;quot;linear&amp;quot;);

PyPlot.savefig(&amp;quot;images/BedUsage.png&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/media/post/2020-COVID/images/BedUsage.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Bed Usage over time&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;It is clear that the requirements for beds quickly hits the available capacity&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bilibliography&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Bilibliography&lt;/h1&gt;
&lt;p&gt;The Novel Coronavirus Pneumonia Emergency Response Epidemiology Team. The Epidemiological Characteristics of an Outbreak of 2019 Novel Coronavirus Diseases (COVID-19) — China, 2020[J]. China CDC Weekly, 2020, 2(8): 113-122. &lt;a href=&#34;http://weekly.chinacdc.cn/en/article/id/e53946e2-c6c4-41e9-9a9b-fea8db1a8f51&#34;&gt;LINK&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>RNN Compressive Memory Part 1: A high level introduction.</title>
      <link>/2020/03/07/rnn-compressive-memory-part-1.html</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/2020/03/07/rnn-compressive-memory-part-1.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#recurrent-neural-networks-rnn&#34;&gt;Recurrent Neural Networks (&lt;em&gt;RNN&lt;/em&gt;)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#from-simple-rnns-to-lstms&#34;&gt;From simple RNNs to LSTMs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#longshort-term-memory-rnns&#34;&gt;Long/Short Term Memory RNNs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#attention&#34;&gt;Attention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#beyond-lstm-transformers&#34;&gt;Beyond LSTM: Transformers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#transformer-xl&#34;&gt;Transformer-XL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compressive-transformers&#34;&gt;Compressive Transformers&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compression-scheme&#34;&gt;Compression scheme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compression-training&#34;&gt;Compression training&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#summary&#34;&gt;Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;This is the first post of series dedicated to Compressive Memory of Recurrent Neural Networks. This is inspired by a recent DeepMind paper published in November 2019 on &lt;a href=&#34;https://arxiv.org/abs/1911.05507&#34;&gt;Arxiv&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Currently, the ambition of the series is to follow this plan:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Part 1 (here): A high level introduction to Compressive Memory mechanics starting from basic RNNS;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;../../05/20/rnn-compressive-memory-part-2.html&#34;&gt;Part 2&lt;/a&gt;: a detailed explanation of the TransformerXL;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 3: an implementation using PyTorch (soon);&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part 4: finally, its application to time series (soon).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most likely, this will be fine-tuned over time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Big thanks to &lt;a href=&#34;https://gmarti.gitlab.io/&#34;&gt;Gautier Marti&lt;/a&gt; and &lt;a href=&#34;http://zoonek.free.fr/blosxom/&#34;&gt;Vincent Zoonekynd&lt;/a&gt; for their suggestions and proof-reading!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Additional diagrams (14 March 2020)&lt;/p&gt;
&lt;div id=&#34;recurrent-neural-networks-rnn&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Recurrent Neural Networks (&lt;em&gt;RNN&lt;/em&gt;)&lt;/h2&gt;
&lt;div id=&#34;from-simple-rnns-to-lstms&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;From simple RNNs to LSTMs&lt;/h3&gt;
&lt;p&gt;Traditional neural networks were developed to train/run on information provided in a single step in a consistent format (e.g. images with identical resolution). Conceptually, a neural network could similarly be taught on sequential information (e.g. a video as a series of images) looking at it as a single sample, but that would require (1) being trained on the full sequence (e.g. an entire video), (2) being able to cope with information of variable length (i.e. short vs. long video). (1) is computationally intractable, and (2) means that units analysing later parts of the video would not be receiving as much training as earlier units when ideally they should be all share the same amount of training .&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/media/post/2020-rnn-compressive-memory/Recurrent_neural_network_unfold.svg&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;strong&gt;Basic RNN&lt;/strong&gt; (source: &lt;em&gt;Wikipedia&lt;/em&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The original RNN address those issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sequences are chopped in small consistent sub-sequences (say, a &lt;em&gt;segment&lt;/em&gt; of 10 images, or a group of 20 words).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An RNN layer is a group of blocks (or &lt;em&gt;cells&lt;/em&gt;), each receiving a single element of the segment as input. Note that here &lt;em&gt;layer&lt;/em&gt; does not have the traditional meaning of a layer of neural units fully connected to a previous layer of units. It is a layer of RNN cells. Within each cell, quite a few things happen, including using layers of neural units. From here on, a &lt;em&gt;layer&lt;/em&gt; will refer to an &lt;em&gt;RNN layer&lt;/em&gt; and not a layer of neural units..&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Within a layer, cells are identical: they have the same parameters.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Although each element of a sequence might be of interest on its own, it only becomes really meaningful in the context of the other elements. Each cell contains a state vector (called &lt;em&gt;hidden state&lt;/em&gt;). Each cell is trained using an individual element from a segment and the hidden state from the preceding cell. Training the network means training the creation of those states. Passing of the hidden state transfers some context or memory from prior elements of the segment. The cells receiving a segment form a single layer. Each cell would typically (but not necessarily) also include an additional sub-cell to create an output as a function of the hidden step. In that case, the output of a layer can then be used as input of new RNN layer.&lt;/p&gt;
&lt;p&gt;A layer is trained passing hidden states from prior cells to later cells. The hidden state from prior elements is used to contextualise a current element. To use context from later elements (e.g. in English, a noun giving context to a preceding adjective), a separate layer is trained where context instead passes from later to prior elements. Those forward and backward layers jointly create a &lt;em&gt;bidirectional RNN&lt;/em&gt; .&lt;/p&gt;
&lt;p&gt;Historically, RNNs applied to NLP deal with elements which are either one-hot encoded (either letters, or, more efficient, tokens), or word embeddings often normalised as unit vectors (for example see &lt;a href=&#34;https://nlp.stanford.edu/projects/glove/&#34;&gt;Word2Vec&lt;/a&gt; and &lt;a href=&#34;https://nlp.stanford.edu/projects/glove/&#34;&gt;GloVe&lt;/a&gt;). RNN cells therefore deal with values between 0 and 1. Typically, non-linearity is brought by &lt;span class=&#34;math inline&#34;&gt;\(tanh\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(sigmoid\)&lt;/span&gt; activations which guarantee unit values within that range. Those activation functions quickly have very flat gradients. Segments often have 10s or 100s of elements. Because of vanishing gradients, a hidden state receives little information from distant cells (training gradients are hardly influenced by gradients of distant cells).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;longshort-term-memory-rnns&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Long/Short Term Memory RNNs&lt;/h3&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/media/post/2020-rnn-compressive-memory/Long_Short-Term_Memory.svg&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;strong&gt;Basic LSTM RNN&lt;/strong&gt; (source: &lt;em&gt;Wikipedia&lt;/em&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Long/Short Term Memory RNNs (&lt;em&gt;LSTM&lt;/em&gt;) address this by passing two states:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a hidden state &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; as described above trained with non-linearity: this is the &lt;em&gt;short-term memory&lt;/em&gt;; and,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;another hidden state &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; (called &lt;em&gt;context&lt;/em&gt;) weighting previous contexts with a simple exponential moving average (in &lt;em&gt;Gated Recurrent Units&lt;/em&gt;) or a slightly more complicated version thereof in the original LSTM model structure. Determining the optimal exponential decay is part of the training process. This minimally processed state is the &lt;em&gt;long-term memory&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LTSM can also be made bidirectional.&lt;/p&gt;
&lt;p&gt;Without going into further details, note that each &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\tanh\)&lt;/span&gt; orange block represents matrix of parameters to be learned.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;attention&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Attention&lt;/h3&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/media/post/2020-rnn-compressive-memory/Attention_RNN.svg&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;&lt;strong&gt;Attention RNN&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RNN were further extended with an &lt;em&gt;attention mechanism&lt;/em&gt;. Blog posts on attention by &lt;a href=&#34;https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/&#34;&gt;Jay Alammar&lt;/a&gt; and &lt;a href=&#34;https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html&#34;&gt;Lilian Weng&lt;/a&gt; are good introductions.&lt;/p&gt;
&lt;p&gt;A multi-layer RNN takes the output a layer and uses it as input for the next. With the attention mechanism, the outputs go through an attention unit.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;beyond-lstm-transformers&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Beyond LSTM: Transformers&lt;/h3&gt;
&lt;p&gt;RNNs were then simplified (insert large air quotes) with &lt;em&gt;Transformers&lt;/em&gt; (using what is called &lt;em&gt;self-attention&lt;/em&gt;) that significantly reduce the number of model parameters and can be efficiently parallelised with minimum model performance impact. For an extremely clear introduction to those significant improvements, you cannot do better than reading , and by &lt;a href=&#34;http://www.peterbloem.nl/blog/transformers&#34;&gt;Peter Bloem&lt;/a&gt; on transformers. The following assumes that you are broadly familiar with those ideas.&lt;/p&gt;
&lt;p&gt;The basic transformer structure uses self-attention where, for a given element (the &lt;em&gt;query&lt;/em&gt;), the transformer looks at the other elements of the segment (the &lt;em&gt;keys&lt;/em&gt;) to determine how much ‘attention’ other elements of the segment influence the role of the query in changing the hidden state.&lt;/p&gt;
&lt;p&gt;Broadly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The query is projected in some linear space (a matrix &lt;span class=&#34;math inline&#34;&gt;\(W_q\)&lt;/span&gt;). That’s basically an embedding which is part of the model training.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All the other elements, the keys, are projected in another linear space (a matrix &lt;span class=&#34;math inline&#34;&gt;\(W_k\)&lt;/span&gt;); another embedding which is part of the model training.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The similarity (perharps &lt;em&gt;affinity&lt;/em&gt; would be a better word) between the projected query and each projected key is calculated with a dot product / cosine distance. This is exactly the approach of basic recommender systems with the difference that the recommendation is between sets of completely different nature (for example affinity between users and movies). Note that although query and keys are elements of identical type, they are embedded into different spaces with different projections matrices.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We now have a vector of the same size as the segment length (one cosine distance per input element). It goes through another layer (a matrix &lt;span class=&#34;math inline&#34;&gt;\(W_v\)&lt;/span&gt;) to give a &lt;em&gt;value&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The triplet of &lt;span class=&#34;math inline&#34;&gt;\(\left( W_q, W_k, W_v \right)\)&lt;/span&gt; is called an &lt;em&gt;attention head&lt;/em&gt;. Actual models would include multiple heads (of the order of 10), and the output of a transformer layer could then feed into a new transformer layer.&lt;/p&gt;
&lt;p&gt;This model is great until you notice that the dot product / cosine similarity is commutative and does not reflect whether a key element is located before or after the query element: order is fundamental to sequential information (“quick fly” vs. “fly quick”). To address this, the input elements are always enriched with a positional embedding: the input elements are concatenated with positional information showing where they stand within a segment.&lt;/p&gt;
&lt;p&gt;Note that a transformer layer is trained on a segment using only the information from that segment. This is fine to train on sentences, but it cannot really account for more distant relationships between words within a lengthy paragraph, let alone a full text.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;transformer-xl&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Transformer-XL&lt;/h3&gt;
&lt;p&gt;Transformers have been further improved with &lt;a href=&#34;https://ai.googleblog.com/2019/01/transformer-xl-unleashing-potential-of.html&#34;&gt;Tranformer-XL&lt;/a&gt; (XL = extra long) which are trained using hidden states from previous segments, therefore using information from several segments, to improve a model’s memory span.&lt;/p&gt;
&lt;p&gt;Conceptually, this is an obvious extension of the basic transformer to increase its memory span. But there is a fundamental problem. Going back to the basic transformer, each element includes its absolute position within the segment. The position of the first word of the segment is 1, that of the last one is, say, 250 . Such a scheme breaks down as soon as the state of the previous segment is taken into account. Word 1 of the current segment obviously comes before word 250, but has to come after word 250 of the previous segment. The absolute position encoding does not reflect the relative position of elements located in different segments.&lt;/p&gt;
&lt;p&gt;The key contribution of the Transformer-XL is to develop a relative positional encoding that allows hidden state information to cross segment boundaries. In their implementation, the authors evaluate that the attention length, being basically how many hidden states are used, is 450% longer that the basic transformer. That’s going from sentence length to full paragraph, but still far from a complete book.&lt;/p&gt;
&lt;p&gt;A side, but impressive, benefit is that the evaluation speed of the model, or it use once trained, is significantly increased thanks to the relative addressing (the paper states up to a 1,800-fold increase depending on the attention length).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;compressive-transformers&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Compressive Transformers&lt;/h2&gt;
&lt;p&gt;Full text understanding cannot be achieved by simply lengthening segment sizes from 100s to the &lt;a href=&#34;https://blog.reedsy.com/how-many-words-in-a-novel/&#34;&gt;word count&lt;/a&gt; of a typical novel (about 100,000). When training a model routinely takes 10s of hours on GPU clusters, an increase by 3 orders of magnitude is not realistic.&lt;/p&gt;
&lt;p&gt;In a recent &lt;a href=&#34;https://arxiv.org/abs/1911.05507&#34;&gt;paper&lt;/a&gt;, DeepMind proposes a new RNN model called &lt;em&gt;Compressive Transformers&lt;/em&gt;.&lt;/p&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Transformer-XL uses the hidden state of a prior segment (&lt;span class=&#34;math inline&#34;&gt;\(h_{T-1}\)&lt;/span&gt;) to improve the training of the current segment (&lt;span class=&#34;math inline&#34;&gt;\(h_{T}\)&lt;/span&gt;). When moving to the next segment, training (&lt;span class=&#34;math inline&#34;&gt;\(h_{T+1}\)&lt;/span&gt;) now only uses &lt;span class=&#34;math inline&#34;&gt;\(h_{T}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(h_{T-1}\)&lt;/span&gt; is discarded. To increase the memory span, one could train using more past segments at the expense of increase in memory usage and computation time (quadratic). The actual Transformer-XL uses the hidden states of several previous segments, but the discarding mechanism will remain.&lt;/p&gt;
&lt;p&gt;The key contribution of the Compressive Transformers is the ability to retain salient information from those otherwise discarded past states. Instead of being discarded, they are stored in compressed form.&lt;/p&gt;
&lt;p&gt;Each Transformer-XL layer is now trained with prior hidden states (&lt;em&gt;primary memory&lt;/em&gt;) and the &lt;em&gt;compressed memory&lt;/em&gt; of older hidden states.&lt;/p&gt;
&lt;p&gt;As an aside, although not explicitly mentioned, we should note that the ‘-XL’ aspect of the Transformer-XL and the memory compression mechanics are conceptually independent from the actual types of RNN cell. Simple RNNs, GRUs or LSTMs could be trained using the hidden states of past segments (not dissimilar to state/context peeking into past cells in certain RNN variants). But the performance benefit of Transformer-XL is such that the paper only focuses on transformer-XL.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;compression-scheme&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Compression scheme&lt;/h3&gt;
&lt;p&gt;As compared to Transformer-XL, the key difference is the compression scheme. The rest of the model seems identical.&lt;/p&gt;
&lt;div id=&#34;size-parameters&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Size parameters&lt;/h4&gt;
&lt;p&gt;The size of the model is described with a few size parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt;: size of a segment = the number of cells in a layer.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n_m\)&lt;/span&gt;: number of hidden states in the primary uncompressed memory (like the Transformer-XL). &lt;span class=&#34;math inline&#34;&gt;\(n_m\)&lt;/span&gt; is a multiple of &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt;. The primary memory is a FIFO buffer: the first (oldest) memories will be the first to be later compressed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n_{cm}\)&lt;/span&gt;: number of compressed hidden states in the compressed memory. States in the compressed memory will compress an old segment of size &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt; dropping out of the primary memory. &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; is an information compression ratio from &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt; primary memory entries into compressed memory entries. There can be two ways of applying this compression ratio, which both reduce the number of hidden states by the same ratio:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; uncompressed layers could create a single compressed hidden state of identical size. This merges the information of a group of elements (e.g. &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; words) into a single hidden state. In this case, &lt;span class=&#34;math inline&#34;&gt;\(n_s\)&lt;/span&gt; is proportional to &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(n_{cm}\)&lt;/span&gt; is proportional to &lt;span class=&#34;math inline&#34;&gt;\(n_s / c\)&lt;/span&gt;. The authors do not use this approach. It would enforce a sub-segmentation of an uncompressed segment at arbitrary intervals (why group 3 words instead of 5 or 7…)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instead, the authors use dimension reduction: a single uncompressed hidden state is compressed into a new hidden state with &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; times fewer hidden states. If the size of the hidden state of a Transformer-XL cell is &lt;span class=&#34;math inline&#34;&gt;\(n_h\)&lt;/span&gt;, hidden states in the primary memory will have the same size, and the compressed memory hidden states will have a size of &lt;span class=&#34;math inline&#34;&gt;\(n_h / c\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By way of example, a segment could have 100 cells (&lt;span class=&#34;math inline&#34;&gt;\(n_s = 100\)&lt;/span&gt;). This segment could be trained with the hidden states of the past 3 segments’ training (&lt;span class=&#34;math inline&#34;&gt;\(n_m = 3 * n_s = 300\)&lt;/span&gt;). When training the next segment, an old segment of size 100 becomes available for compression which will create 100 new hidden states.&lt;/p&gt;
&lt;p&gt;This example is for a single layer. The same scheme would be replicated for each layer of the model&lt;/p&gt;
&lt;p&gt;Note that the paper only contemplates a single set of compressed memories. There could also be multiple generations of compressed memories, primary memory compresses in generation 1, then compressing into generation 2…&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;compression-functions&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Compression functions&lt;/h4&gt;
&lt;p&gt;A compressed hidden state is created from &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; primary memory hidden states. When training on texts with word embeddings,the authors used a value of &lt;span class=&#34;math inline&#34;&gt;\(c=3\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(c=4\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Several compression schemes are explored in the paper:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;max or mean pooling with a stride of &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;. This is typical of image convolution networks - no explanation required.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1-dimensional convolution with a stride of &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;. This is also typical of image convolution network apart from being one-dimensional. This requires parameter training.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/1511.07122.pdf&#34;&gt;dilated convolution&lt;/a&gt;. In practice image convolutions have shown to be inadequate for sequential information where dependencies can be at both short and long ranges: working at different scales makes sense. Dilated convolutions use convolution filters that are contracted and dilated versions of a template to be trained.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a &lt;em&gt;most-used&lt;/em&gt; mechanism that identifies and retains part of the hidden states according to their importance in the cells training gauged by the attention they received.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;compression-training&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Compression training&lt;/h3&gt;
&lt;p&gt;Training the compression parameters is done separately from the optimisation of the Transformer-XL cells.&lt;/p&gt;
&lt;p&gt;The purpose of the compressed memory is to provide a compressed and lossy representation of the primary memory (hidden states) or the attention heads parameters: the quality of the compression mechanics is assessed by how well the original information can be re-generated from it. In essence, the compressed hidden states are a compressed representations to a learned representation vector in an auto-encoder. This is the training mechanics used by the authors.&lt;/p&gt;
&lt;p&gt;As in an auto-encoder, the representation is learned by comparing the original information to its reconstruction. This training is kept completely independent from the training of the transformers: the auto-encoding loss and gradients do not impact the attention heads’ parameters.&lt;/p&gt;
&lt;p&gt;Conversely, the loss and gradients of the attention heads’ training do not flow into the training of the compression scheme.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;summary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This was a high level introduction of RNNs all the way up to Compressive Memory mechanics. Next, the algorithm’s nitty-gritty.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>HarvardX Gitbooks available</title>
      <link>/2019/12/12/harvardx-gitbooks-available.html</link>
      <pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate>
      <guid>/2019/12/12/harvardx-gitbooks-available.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Both capstones for the HarvardX certificates are now available. Just click on the &lt;code&gt;Projects&lt;/code&gt; link!&lt;/p&gt;
&lt;p&gt;If Gitbooks are not your thing, at the top of their main page, there is a download link to a pdf version.&lt;/p&gt;
&lt;p&gt;They make for a good knock-me-asleep reading…&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HarvardX Final Report - LendingClub dataset</title>
      <link>/2019/12/11/harvardx-final-report-lendingclub-dataset.html</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      <guid>/2019/12/11/harvardx-final-report-lendingclub-dataset.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;After 3 months of work, the final report for the HarvardX Data Science course was submitted.&lt;/p&gt;
&lt;p&gt;It is based on the LendingClub dataset. LendingClub is a peer-2-peer lender. This is a matching of private borrowers and investors. Small amounts, fairly high risk (if they could, borrowers would probably have had a bank involved). Surprisingly, after tapping a market of individual lenders, the biggest lenders are now the banks. To inform the investors, LendingClub make historical information publicly available.&lt;/p&gt;
&lt;p&gt;This work went through many blind alleys. I won’t list them, they are in the report (post-mortem section). But it was an overall enriching experience. I learned a lot, often about limitations of what I tried (the dataset is big with a few millions samples (big for an old laptop), with many (ca. 150) mispecified mixed categorical and numeric variables). The experience will be filed in the &lt;em&gt;‘it-builds-character’&lt;/em&gt; category…&lt;/p&gt;
&lt;p&gt;One point that is still tingling my mind is learning about Conditional Inference Trees used to bin variables. That is then used for logistic regression to predict probabilities of loan default.&lt;/p&gt;
&lt;p&gt;Why are those trees interesting? They are sourced in information theory and measure the information content of a prediction variable to predict a binary response. The prediction variable is then partitioned in a few intervals (bins). What is great?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The measurement does NOT rely on the value of the prediction variable. This means that variable NAs go from being a nuisance to being stashed in a bin of their own treated as any other bin.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The logistic regression context predicates binary variables which were perfect for the purpose of this report. But those trees do not require binary outcomes. They rely on what are called &lt;em&gt;Weight of Evidence&lt;/em&gt; (calculated for each bin) and &lt;em&gt;Information Value&lt;/em&gt; (calculated for each variable).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The calculations are very quick (about 1/10th second to bin 1 million samples) with a small memory footprint.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In other words, whatever comes in, we do not have to worry about scaling/z-scoring/filling NAs; it is quickly reformatted into a handful (literally of that order of magnitude depending on parameters used) based on the relevance to predicting what needs to come out.&lt;/p&gt;
&lt;p&gt;If I didn’t know better, this should be called &lt;em&gt;model impedance matching&lt;/em&gt; (electrical engineers can explain)!&lt;/p&gt;
&lt;p&gt;Apart from that, the number of avenues to explore with this dataset (especially using data from other sources) could fill many more months. I listed a list of possible techniques in the report’s conclusion. This is what does and will keep banks’ credit risk departments busy and well-staffed…&lt;/p&gt;
&lt;p&gt;I am working on making the MovieLens and LendingClub reports available as gitbooks. To be announced.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick Thought: Universal translator and same language translator</title>
      <link>/2019/10/25/quick-idea-universal-translator-and-same-language-translator.html</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/2019/10/25/quick-idea-universal-translator-and-same-language-translator.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Quick Thoughts are random thoughts looking for comments&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s imagine a universal translator able to translate any language to any language. Sourcing a corpus of pair translation is a major hurdle. However there is an almost infinite corpus of pair translations: a language with itself; translating English to English is easy, even for a computer.&lt;/p&gt;
&lt;p&gt;Let’s give the blackbox universal translator three inputs: a source text, the language of the source text, the language of the desired translation. What would be the consequences for the learning system inside the blackbox of being constrained that if the languages are the same, the output has to be identical to the input?&lt;/p&gt;
&lt;p&gt;Obviously, the blackbox could quickly learn that bypassing the translation does the trick. However, that would probably require the internal circuitry to allow for the bypass, and that could be constrained out. So:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Could we expect any interesting result?&lt;/li&gt;
&lt;li&gt;Could the input to be eventually forced down to a language-independent universal representation?&lt;/li&gt;
&lt;li&gt;Let’s say there is a language-independent universal representation kernel. If the input comes in without information of which is the output language, and the output has no information of what the input language was, does it force the network to create a universal representation, or would it just withered away?&lt;/li&gt;
&lt;li&gt;Is it possible to &lt;em&gt;invert&lt;/em&gt; a network? Probably not in a truly bijective way, but to model the fact that text representation &lt;span class=&#34;math inline&#34;&gt;\(\rightarrow\)&lt;/span&gt; universal representation is the &lt;em&gt;inverse&lt;/em&gt; (for some definition of the word) of universal representation &lt;span class=&#34;math inline&#34;&gt;\(\rightarrow\)&lt;/span&gt; text representation of the same language?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Comments welcome&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Neural Network - Incremental Growth</title>
      <link>/2019/10/23/neural-network-incremental-growth.html</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/2019/10/23/neural-network-incremental-growth.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#draft-1&#34;&gt;&lt;strong&gt;&lt;em&gt;DRAFT 1&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#background&#34;&gt;Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#singular-matrix-decomposition&#34;&gt;Singular matrix decomposition&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#where-next&#34;&gt;Where next?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#back-to-svd&#34;&gt;Back to SVD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#regularisation&#34;&gt;Regularisation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#vector-coordinates&#34;&gt;Vector coordinates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eigenvalues&#34;&gt;Eigenvalues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#threshold&#34;&gt;Threshold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#by-2-decision-matrix&#34;&gt;2-by-2 decision matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#todo-other-principal-components-methods&#34;&gt;[TODO] Other Principal Components methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#todo-proof-of-the-pudding&#34;&gt;[TODO] Proof of the pudding…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#limitations-and-further-questions&#34;&gt;Limitations and further questions&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#further-questions&#34;&gt;Further questions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#litterature&#34;&gt;Litterature&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;div id=&#34;draft-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;strong&gt;&lt;em&gt;DRAFT 1&lt;/em&gt;&lt;/strong&gt;&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;We all have laptops. But le’ts face it, even in times of 32GB of RAM and NVMe2 drives, forget about running any interesting TensorFlow model. You need to get an external GPU, build your own rig, or very quickly pay a small fortune for cloud instances.&lt;/p&gt;
&lt;p&gt;Back in 1993, I read a paper about growing neural networks neuron-by-neuron. I have no other precise recollection about this paper apart from the models considered being of the order of 10s of neurons and the weight optimisation being made on a global basis, i.e. not layer-by-layer like backpropagation. Nowadays, it is still too often the case that finding a network structure that solves a particular problem is a random walk: how many layers, with how many neurons, with which activation functions? Regularisation methods? Drop-out rate? Training batch size? The list goes on.&lt;/p&gt;
&lt;p&gt;This got me thinking about how a training heuristic could incrementally modify a network structure given a particular training set and, apart maybe from a few hyperparameters, do that with no external intervention. At regular training intervals, a layer&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; will be modified depending on what it &lt;em&gt;seems&lt;/em&gt; able or not to achieve. As we will see, we will use unsupervised learning methods to do this: a layer modification will be independent of the actual learning problem and automatic.&lt;/p&gt;
&lt;p&gt;Many others have looked into that. But what I found regarding self-organising networks is pre-2000, and nothing in the context of deep learning. So it seems that the topic has gone out of fashion because of the current amounts of computing power, or has been set aside for reasons unknown. (See references at the end). In any event, it is interesting enough a question to research it.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;background&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Background&lt;/h1&gt;
&lt;p&gt;Let us look at a simple 1-D layer and decompose what it exactly does. Basically a layer does:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\text{ouput} = f(M \times \text{input})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If the input &lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; has size &lt;span class=&#34;math inline&#34;&gt;\(n_I\)&lt;/span&gt;, the output &lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt; has size &lt;span class=&#34;math inline&#34;&gt;\(n_I\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; being the activation function, we have (where &lt;span class=&#34;math inline&#34;&gt;\(\odot\)&lt;/span&gt; represents the matrix element-wise application of a function):&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
O = f \odot (M \times I)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Then, looking at &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;, what does it really do? At one extreme, if &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; was the identity matrix, it would essentially be useless (bar the activation function&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;). This would be a layer candidate for deletion. The question is then:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Looking at the matrix representing a layer, can we identify which parts are (1) useless, (2) useful and complex enough, or (3) useful but too simplistic?&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here, &lt;em&gt;complex enough&lt;/em&gt; or &lt;em&gt;simplistic&lt;/em&gt; is basically a synonym of “&lt;em&gt;one layer is enough&lt;/em&gt;”, or “&lt;em&gt;more layers are necessary&lt;/em&gt;”.&lt;/p&gt;
&lt;p&gt;The idea to look for important/complex information which where the network needs to grow more complex; and identify trivial information which can be discarded, or can be viewed as minor adjustments to improve error rates (basically overfitting…)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Caveat&lt;/em&gt;: Note that we ignore the activation function. They are key to introduce non-linearity. Without it, a network is only a linear function, i.e. no interest. They have a clear impact on the performance of a network.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;singular-matrix-decomposition&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Singular matrix decomposition&lt;/h1&gt;
&lt;p&gt;There exists many ways to decompose a matrix. Singular matrix decomposition (&lt;em&gt;SVD&lt;/em&gt;) &lt;span class=&#34;math inline&#34;&gt;\(M = O \Sigma I^\intercal\)&lt;/span&gt; is an easy and efficient way to interpret what a given matrix does. SVD builds on the eigenvectors (expressed in an orthonormal basis), and eigenvalues. (Note that &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; is real-valued, so we use the transpose notation &lt;span class=&#34;math inline&#34;&gt;\(M^\intercal\)&lt;/span&gt; instead of the conjugate transpose &lt;span class=&#34;math inline&#34;&gt;\(M^*\)&lt;/span&gt;.)&lt;/p&gt;
&lt;p&gt;In a statistical world, SVD (with eigenvalues ordered by decreasing value) is how to do principal component analysis(&lt;em&gt;PCA&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;In a geometrical context, SVD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;takes a vector (expressed in the orthonormal basis);&lt;/li&gt;
&lt;li&gt;re-expresses onto a new basis made of the eigenvectors (that would only exceptionally be orthonormal);&lt;/li&gt;
&lt;li&gt;dilates/compresses those components by the relevant eigenvalues;&lt;/li&gt;
&lt;li&gt;and returns this resulting vector expressed back onto the orthonormal basis.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As presented here, this explanation requires a bit more intellectual gymnastic when the matrix is not square (i.e. when the input and output layers have different dimensions), but the principle remains identical.&lt;/p&gt;
&lt;div id=&#34;where-next&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Where next?&lt;/h3&gt;
&lt;p&gt;Taking the statistical and geometrical points of view together, the layer (matrix &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;) shuffles the input vector in its original space space where some specific directions are more important than others. Those directions are linear combinations of the input neurons, each combinations is along the eigenvectors. Those combinations are given more or less importance as expressed by the eigenvalues. (Note that the squares of the eigenvalues expressed how much information each combination brings to the table.)&lt;/p&gt;
&lt;p&gt;Intuitively, the simplest and most useless &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; would be the identity matrix (the input units are repeated), or zero matrix (the input units are dropped because useless). Let us repeat the caveat that the activation function is ignored.&lt;/p&gt;
&lt;p&gt;If compared to the identity matrix, the SVD shows that &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; includes (at least) two types of important information identified:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What are interesting combinations of the input units? This is expressed by how much the input vector is rotated in space.&lt;/li&gt;
&lt;li&gt;Independently from whether a combination is complicated or not (i.e. multiple units, or unit passthrough), how an input is amplified (as expressed by the eigenvalues).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The idea is then produce a 2x2 decision matrix with high/low rotation mess and high/low eigenvalues.&lt;/p&gt;
&lt;p&gt;A picture is gives the intuition of what we are after:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/media/post/3-random-thoughts/2019-10-23-neural-network-incremental-growth/Network-Incremental-Growth-Matrix-Split.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Transformation of the Layer Matrix&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Looking from top to bottom at what the “after” matrices would be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Part of the original layer, immediately followed by a new one (we will see below what that would look like). The intuition is that this layer is really messing things up down the line, or seems very sensitive.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part of the original layer where the number of units would be increased (here doubled as an example).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Part of the original layer kept &lt;em&gt;functionally&lt;/em&gt; essentially as is.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Delete the rest which is either not sensitive to input or outputs nothings. This would be within a certain precision. That is basically a form of regularisation preventing the overall model to be too sensitive. I am aware that there are other types of regularisations, but that will go in the limitations category.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The next layer would take as input all the transformed outputs.&lt;/p&gt;
&lt;p&gt;In practice, the picture presents the matrices separated. This is for ease of understanding. In reality the same effect would be achieved if the three dark blue sub-layers are merged in a single layer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;back-to-svd&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Back to SVD&lt;/h1&gt;
&lt;p&gt;Let us assume that there are &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; input units and &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; output units. &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; then is of dimensions &lt;span class=&#34;math inline&#34;&gt;\(m \times n\)&lt;/span&gt;. The matrices of the SVD have dimensions:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{matrix}
M          &amp;amp; = &amp;amp; O          &amp;amp; \Sigma     &amp;amp; I^\intercal \\
m \times n &amp;amp;   &amp;amp; m \times m &amp;amp; m \times n &amp;amp; n \times n \\
\end{matrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that instead of using &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt; to name the sub-matrices of the SVD, we use &lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt; to represent &lt;em&gt;input&lt;/em&gt; and &lt;em&gt;output&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt; can be written as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
I =
\begin{pmatrix} |   &amp;amp;        &amp;amp; |    \\ i_1 &amp;amp; \cdots &amp;amp; i_m  \\ |   &amp;amp;        &amp;amp; |    \\ \end{pmatrix} 
\qquad \text{and} \qquad
O =
\begin{pmatrix} |   &amp;amp;       &amp;amp; | \\ o_1 &amp;amp; \cdots &amp;amp; o_n \\ |   &amp;amp;       &amp;amp; | \\ \end{pmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Then:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
M =
O \Sigma I^\intercal =
\begin{pmatrix} | &amp;amp;&amp;amp; | \\ o_1 &amp;amp; \dots &amp;amp; o_m \\ | &amp;amp; &amp;amp; | \\ \end{pmatrix}
\begin{pmatrix} \sigma_1 \\ &amp;amp; \sigma_2 \\ &amp;amp;&amp;amp; \ddots \\ &amp;amp;&amp;amp;&amp;amp; \sigma_r \\ &amp;amp;&amp;amp;&amp;amp;&amp;amp; 0 \\ &amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp; \ddots \\ &amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp; 0 \\ \end{pmatrix}
\begin{pmatrix} - &amp;amp; i_1 &amp;amp; - \\ &amp;amp; \vdots &amp;amp; \\ -  &amp;amp; i_n &amp;amp; - \\ \end{pmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt; has &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; non-zero eigenvalues.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;regularisation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Regularisation&lt;/h1&gt;
&lt;p&gt;At this stage, we can regularise all components.&lt;/p&gt;
&lt;div id=&#34;vector-coordinates&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Vector coordinates&lt;/h2&gt;
&lt;p&gt;For each vector &lt;span class=&#34;math inline&#34;&gt;\(i_k\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(o_k\)&lt;/span&gt;, we could zero its coordinates when below a certain threshold (in absolute value). All the coordinates will &lt;span class=&#34;math inline&#34;&gt;\(-\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; since each vector has norm 1 (&lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt; are orthonormal), therefore all of them will be regularised in similar ways.&lt;/p&gt;
&lt;p&gt;After regularisation, the matrices will not be orthonormal anymore. They can easily be made normal by scaling up by &lt;span class=&#34;math inline&#34;&gt;\(\frac{1}{\sum_{k}i_k^2}\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(\frac{1}{\sum_{k}o_k^2}\)&lt;/span&gt;. There is no generic way to revert to an orthogonal basis and keep the zeros.&lt;/p&gt;
&lt;p&gt;We need a way to measure the &lt;code&gt;rotation messiness&lt;/code&gt; of each vector. As a shortcut, we can use the proportion of non-zero vector coordinates (after &lt;em&gt;de minimis&lt;/em&gt; regularisation).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;eigenvalues&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Eigenvalues&lt;/h2&gt;
&lt;p&gt;The same can be done for the &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;s. As an avenue of experimentation, those values can not only be zero-ed in places, but also rescale the large values in some non-linear way (e.g. logarithmic or square root rescaling).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;threshold&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Threshold&lt;/h2&gt;
&lt;p&gt;Where to set the threshold is to be experimented with. Mean? Median since more robust? Some quartile?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;by-2-decision-matrix&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2-by-2 decision matrix&lt;/h2&gt;
&lt;p&gt;Based on those regularisation, we would propose the following:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ 
\begin{matrix}
                    &amp;amp; \text{low rotation messiness} &amp;amp; \text{high rotation messiness} \\
\text{high } \sigma &amp;amp; \text{Double height}          &amp;amp; \text{Double depth}            \\
\text{low } \sigma  &amp;amp; \text{Delete}                 &amp;amp; \text{Keep identical}          \\
\end{matrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;todo-other-principal-components-methods&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;[TODO] Other Principal Components methods&lt;/h1&gt;
&lt;p&gt;SVD is PCA. Projects information on hyperplanes.&lt;/p&gt;
&lt;p&gt;Reflect on non-linear versions: Principal Curves, Kernel Principal Components, Sparse Principal Components, Independent Component Analysis. (_Elements of Statistical Learning s. 14.5 seq.).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;todo-proof-of-the-pudding&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;[TODO] Proof of the pudding…&lt;/h1&gt;
&lt;p&gt;Implementations!!!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;limitations-and-further-questions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Limitations and further questions&lt;/h1&gt;
&lt;div id=&#34;limitations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Limitations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Only 1-D layers. Higher-order SVD is in principle feasible for higher order tensors. Other methods?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We delete the eigenvectors associated to low eigenvalues and limited rotations. There are other forms of regularisations, e.g. random weight cancelling that would not care about anything eigen-.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;What is the real impact of ignoring the activation function? PCA requires centered values. Geometrically, uncentered values would mean more limited rotations since samples would be in quadrant far from 0.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;further-questions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Further questions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The final structure is a direct product of the training set. What if the training is done differently (batches sized or ordered differently)?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;What about training many variants with different subsets of the training set and using ensemble methods?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The eigenvalues could be modified when creating the new layers. By decreasing the highest eigevalues (in absolute value), we effectively regularise the layers outputs. This decrease could bring additional non-linearity if the compression ratio depends on the eigengevalue (e.g. replacing it by it square root). And this non-linearty would not bring additional complexity to the back-propagation algorithm, or auto-differentiated functions: it only modifies the final values if the new matrices.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;litterature&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Litterature&lt;/h1&gt;
&lt;p&gt;Here are a few summary litterature references related to the topic.&lt;/p&gt;
&lt;div id=&#34;the-elements-of-statistical-learning&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;The Elements of Statistical Learning&lt;/h4&gt;
&lt;p&gt;The ESL top of p 409 proposes PCA to interpret layers, i.e. to improve the interpretability of the decisions made by a network.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;neural-network-implementations-for-pca-and-its-extensions&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Neural Network Implementations for PCA and Its Extensions&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://downloads.hindawi.com/archive/2012/847305.pdf&#34; class=&#34;uri&#34;&gt;http://downloads.hindawi.com/archive/2012/847305.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Uses neural networks as a substitute for PCA.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;an-incremental-neural-network-construction-algorithm-for-training-multilayer-perceptrons&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;An Incremental Neural Network Construction Algorithm for Training Multilayer Perceptrons&lt;/h4&gt;
&lt;p&gt;Aran, Oya, and Ethem Alpaydin. “An incremental neural network construction algorithm for training multilayer perceptrons.” Artificial Neural Networks and Neural Information Processing. Istanbul, Turkey: ICANN/ICONIP (2003).&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cmpe.boun.edu.tr/~ethem/files/papers/aran03incremental.pdf&#34; class=&#34;uri&#34;&gt;https://www.cmpe.boun.edu.tr/~ethem/files/papers/aran03incremental.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;kohonen-maps&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Kohonen Maps&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Self-organizing_map&#34; class=&#34;uri&#34;&gt;https://en.wikipedia.org/wiki/Self-organizing_map&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;self-organising-network&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Self-Organising Network&lt;/h4&gt;
&lt;div id=&#34;a-self-organising-network-that-grows-when-required-2002&#34; class=&#34;section level5&#34;&gt;
&lt;h5&gt;A Self-Organising Network That Grows When Required (2002)&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8763&#34; class=&#34;uri&#34;&gt;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8763&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-cascade-correlation-learning-architecture&#34; class=&#34;section level5&#34;&gt;
&lt;h5&gt;The Cascade-Correlation Learning Architecture&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.125.6421&#34; class=&#34;uri&#34;&gt;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.125.6421&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Growth with quick freeze as a way to avoid the expense of back-propagation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;soinnself-organizing-incremental-neural-network&#34; class=&#34;section level5&#34;&gt;
&lt;h5&gt;SOINN：Self-Organizing Incremental Neural Network&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;http://www.haselab.info/soinn-e.html&#34; class=&#34;uri&#34;&gt;http://www.haselab.info/soinn-e.html&lt;/a&gt;
&lt;a href=&#34;https://cs.nju.edu.cn/rinc/SOINN/Tutorial.pdf&#34; class=&#34;uri&#34;&gt;https://cs.nju.edu.cn/rinc/SOINN/Tutorial.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Seems focused on neuron by neuron evolution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;We will only consider modifying the network layer by layer, not neuron by neuron.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;This could actually be a big limitation of this discussion. In reality, even an identity matrix yields changes by piping the inputs through a new round of non-linearity, which is not necessarily identical to the preceding layer&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>HarvardX Data Science course - First final project</title>
      <link>/2019/10/05/harvardx-data-science-course-first-final-project.html</link>
      <pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/2019/10/05/harvardx-data-science-course-first-final-project.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;I recently finished to penultimate &lt;a href=&#34;https://github.com/Emmanuel-R8/capstone-movielens/blob/master/MovieLens.pdf&#34;&gt;final assignment&lt;/a&gt; for the &lt;a href=&#34;https://www.edx.org/professional-certificate/harvardx-data-science&#34;&gt;HarvardX Data Science course&lt;/a&gt;. The Stanford course was clearly machine learning. This one is definitely lighter on the machine learning and much heavier on the data science: how to source, clean and visualise data are key skills. The targeted knowledge is more traditional probabilities/statistics. Long-existing fundamental techniques like inference, polling are there.&lt;/p&gt;
&lt;p&gt;This time R is the centre tool of the course. It makes clear sense. When I started learning it about 15 years ago, I loathed the multiple gotchas. Since then, new libraries have simplified base R and removed its exceptions and exceptions to exceptions. In addition the &lt;code&gt;Rcpp&lt;/code&gt; library has eased implementation of efficient algorithms and interfacing with popular libraries. Still not a speed demon, but not the snail it used to be.&lt;/p&gt;
&lt;p&gt;I won’t go through the project and my models. No revolutionary concepts. Just great results. I took half a day to reimplement in Julia, both to crosscheck and personal training. As expected, a lot easier to read. But the big surprise was the speed difference. Although I didn’t time it, Julia only felt about twice quicker. Credit to the R project folks (I only used matrices operations, no modeling libraries).&lt;/p&gt;
&lt;p&gt;On this report, I got grades that can’t be improved upon. Happy camper.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Stanford Online - Machine Learning C229 </title>
      <link>/2019/08/02/stanford-online-machine-learning-c229.html</link>
      <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
      <guid>/2019/08/02/stanford-online-machine-learning-c229.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#review&#34;&gt;Review&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exercises-and-grading&#34;&gt;Exercises and grading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#summary&#34;&gt;Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;review&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Review&lt;/h1&gt;
&lt;p&gt;I recently completed the Stanford online version of the Machine Learning CS229 course taught by Andrew Ng. There is no need to introduce this course which has reached &lt;em&gt;stardom&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;It often was a trip a trip down memory lane repeating what I studied in the late 90’ies. It was interesting that quite a bit has remained as relevant. Back then, and I am now talking early 90ies, neural networks were still fashionable but computationally intractable past what would hardly be considered a single layer nowadays. Backpropagation was already used, but similarly quickly tedious.&lt;/p&gt;
&lt;p&gt;Enough recalling old times… There was plenty I had not done back then.&lt;/p&gt;
&lt;p&gt;The course was extremely pleasant. The progression made sense, pace was enjoyable. In particular, the blackboard style presentation was great. Following along with pen and paper made things easily stick.&lt;/p&gt;
&lt;p&gt;Every piece of code had to be written in Matlab/Octave. The choice was surprising in those days and age where R has been a mainstay of statistics and statistical learning, and Python is now the language of choice to glue and interface so many optimised C/C++ libraries (in addition to its natural qualities). But the rationale of Matlab/Octave being very natural to implement algorithms where matrices are the mathematical object of choice, made sense. The learning curve was easy, code looked very legible and natural. For short scripts, all good. For anybody who thinks that his/her code will one day be maintained by a psychopath who know his/her address, Matlab/Octave is to be left as a Wikipedia article. Maybe Julia will become a better choice. (Numpy matrix calcs looks very far from mathematical formalism and easy to bug up.)&lt;/p&gt;
&lt;p&gt;The course was light on the theory side. No surprise: long curriculum, few hours. On the flip side, the recurring emphasis on the ‘what does it mean?’, developing intuitions and, in particular, the hammering about bias/complexity or bias/variance trade-off would be of great value to anyone entering the field. There is a somewhat prevalent meme that machine learning only works because we now have train loads of sdcards of data, and that if something doesn’t quite work, just throw more data at it. Hammering that trade off will hopefully make many become at least sceptical. More data is not a magic wand.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;exercises-and-grading&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Exercises and grading&lt;/h1&gt;
&lt;p&gt;The automated grading grading system was surprisingly efficient. There were a few gotchas on exact spelling or white spaces. But overall, no complaints. And given the lack of real-people face-to-face time, this was a nice alternative.&lt;/p&gt;
&lt;p&gt;The regular coding exams were interesting and the backend infrastructure worked great. As time progressed, the difficulty significantly dropped because of the more difficult content (harder to draft an exercise that really really covers content that was superficially addressed). The course 6 exam was clearly the hardest for many of the students.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;summary&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;Worth it? On a personal level, definitely. And impossible to beat the value for money.&lt;/p&gt;
&lt;p&gt;As a carrer-enhancing proposition, it remains to be seen, and I’ll need to see it to believe it.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Hello Blogdown!</title>
      <link>/2019/08/01/hello-blogdown.html</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      <guid>/2019/08/01/hello-blogdown.html</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#blogdown&#34;&gt;Blogdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#setup&#34;&gt;Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#themes&#34;&gt;Themes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;blogdown&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Blogdown&lt;/h1&gt;
&lt;p&gt;I have been a happy user of R markdown and &lt;a href=&#34;https://bookdown.org/&#34;&gt;bookdown&lt;/a&gt; developed by &lt;a href=&#34;https://yixui.name/&#34;&gt;Yixui Xie&lt;/a&gt;. When I decided to start this blog, giving &lt;code&gt;blogdown&lt;/code&gt; a try was a no-brainer. To be honest, it was not my first choice. Jekyll was #1 given it’s good support by GitHub pages. Then I took a dive with Pelican. Both are impressive, but both brought equally painful theming: the base theme sort of works, and only sort of, but anyway was not what I wanted. Attempts to use anything else failed. I didn’t have time to dig into the HTML/CSS templates.&lt;/p&gt;
&lt;p&gt;Blogdown just worked out of the box without any &lt;code&gt;sort of&lt;/code&gt; caveat.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;setup&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Setup&lt;/h1&gt;
&lt;p&gt;Basically, I just followed up the blogdown documentation. As for all his projects, Yixui’s documentation is clear, didactic and shows how much thoughts have gone into making his software easy to use, yet powerful.&lt;/p&gt;
&lt;p&gt;By defaults, blogdown uses the &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;, but a Jekyll backend is in beta.&lt;/p&gt;
&lt;p&gt;Great resources are &lt;a href=&#34;https://aurora-mareviv.github.io/talesofr/2017/08/r-blogdown-setup-in-github/&#34;&gt;R Blogdown Setup in GitHub&lt;/a&gt;, even its valuable update &lt;a href=&#34;https://aurora-mareviv.github.io/talesofr/2018/02/r-blogdown-setup-in-github-2/&#34;&gt;R Blogdown Setup in GitHub (2)&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;themes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Themes&lt;/h1&gt;
&lt;p&gt;As in other solutions, theming is never straightforward. Blogdown uses Hugo themes which cannot always be imported without changes and would need a bit of massaging. Having said that, if you find a them you like, it is just a matter of running &lt;code&gt;blogdown::install_theme(&#34;REPONAME&#34;)&lt;/code&gt;, and the theme will be downloaded and installed in the &lt;code&gt;themes&lt;/code&gt; subdirectory. &lt;code&gt;blogdown&lt;/code&gt; will automatically change the &lt;code&gt;theme:&lt;/code&gt; parameter in the &lt;code&gt;toml&lt;/code&gt; configuration file and the site will be re-generated. Easy enough? Bonus points for &lt;code&gt;Hugo&lt;/code&gt; that takes under 100ms to do that job.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
